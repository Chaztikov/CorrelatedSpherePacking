/* File: test.pyfmodule.c
 * This file is auto-generated with f2py (version:2).
 * f2py is a Fortran to Python Interface Generator (FPIG), Second Edition,
 * written by Pearu Peterson <pearu@cens.ioc.ee>.
 * Generation date: Tue Oct  2 22:54:39 2018
 * Do not edit this file directly unless you know what you are doing!!!
 */

#ifdef __cplusplus
extern "C" {
#endif

/*********************** See f2py2e/cfuncs.py: includes ***********************/
#include "Python.h"
#include "fortranobject.h"
/*need_includes0*/

/**************** See f2py2e/rules.py: mod_rules['modulebody'] ****************/
static PyObject *test.pyf_error;
static PyObject *test.pyf_module;

/*********************** See f2py2e/cfuncs.py: typedefs ***********************/
/*need_typedefs*/

/****************** See f2py2e/cfuncs.py: typedefs_generated ******************/
/*need_typedefs_generated*/

/********************** See f2py2e/cfuncs.py: cppmacros **********************/
#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F
#else
#define F_FUNC(f,F) _##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) _##F##_
#else
#define F_FUNC(f,F) _##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F
#else
#define F_FUNC(f,F) f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_FUNC(f,F) F##_
#else
#define F_FUNC(f,F) f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_FUNC_US(f,F) F_FUNC(f##_,F##_)
#else
#define F_FUNC_US(f,F) F_FUNC(f,F)
#endif

#ifdef DEBUGCFUNCS
#define CFUNCSMESS(mess) fprintf(stderr,"debug-capi:"mess);
#define CFUNCSMESSPY(mess,obj) CFUNCSMESS(mess) \
    PyObject_Print((PyObject *)obj,stderr,Py_PRINT_RAW);\
    fprintf(stderr,"\n");
#else
#define CFUNCSMESS(mess)
#define CFUNCSMESSPY(mess,obj)
#endif

#ifndef max
#define max(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef min
#define min(a,b) ((a < b) ? (a) : (b))
#endif
#ifndef MAX
#define MAX(a,b) ((a > b) ? (a) : (b))
#endif
#ifndef MIN
#define MIN(a,b) ((a < b) ? (a) : (b))
#endif

#if defined(PREPEND_FORTRAN)
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) _F2PYWRAP##F
#else
#define F_WRAPPEDFUNC(f,F) _f2pywrap##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) _F2PYWRAP##F##_
#else
#define F_WRAPPEDFUNC(f,F) _f2pywrap##f##_
#endif
#endif
#else
#if defined(NO_APPEND_FORTRAN)
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) F2PYWRAP##F
#else
#define F_WRAPPEDFUNC(f,F) f2pywrap##f
#endif
#else
#if defined(UPPERCASE_FORTRAN)
#define F_WRAPPEDFUNC(f,F) F2PYWRAP##F##_
#else
#define F_WRAPPEDFUNC(f,F) f2pywrap##f##_
#endif
#endif
#endif
#if defined(UNDERSCORE_G77)
#define F_WRAPPEDFUNC_US(f,F) F_WRAPPEDFUNC(f##_,F##_)
#else
#define F_WRAPPEDFUNC_US(f,F) F_WRAPPEDFUNC(f,F)
#endif


/************************ See f2py2e/cfuncs.py: cfuncs ************************/
static int double_from_pyobj(double* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyFloat_Check(obj)) {
#ifdef __sgi
        *v = PyFloat_AsDouble(obj);
#else
        *v = PyFloat_AS_DOUBLE(obj);
#endif
        return 1;
    }
    tmp = PyNumber_Float(obj);
    if (tmp) {
#ifdef __sgi
        *v = PyFloat_AsDouble(tmp);
#else
        *v = PyFloat_AS_DOUBLE(tmp);
#endif
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (double_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = test.pyf_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}

static int float_from_pyobj(float* v,PyObject *obj,const char *errmess) {
    double d=0.0;
    if (double_from_pyobj(&d,obj,errmess)) {
        *v = (float)d;
        return 1;
    }
    return 0;
}

static int int_from_pyobj(int* v,PyObject *obj,const char *errmess) {
    PyObject* tmp = NULL;
    if (PyInt_Check(obj)) {
        *v = (int)PyInt_AS_LONG(obj);
        return 1;
    }
    tmp = PyNumber_Int(obj);
    if (tmp) {
        *v = PyInt_AS_LONG(tmp);
        Py_DECREF(tmp);
        return 1;
    }
    if (PyComplex_Check(obj))
        tmp = PyObject_GetAttrString(obj,"real");
    else if (PyString_Check(obj) || PyUnicode_Check(obj))
        /*pass*/;
    else if (PySequence_Check(obj))
        tmp = PySequence_GetItem(obj,0);
    if (tmp) {
        PyErr_Clear();
        if (int_from_pyobj(v,tmp,errmess)) {Py_DECREF(tmp); return 1;}
        Py_DECREF(tmp);
    }
    {
        PyObject* err = PyErr_Occurred();
        if (err==NULL) err = test.pyf_error;
        PyErr_SetString(err,errmess);
    }
    return 0;
}


/********************* See f2py2e/cfuncs.py: userincludes *********************/
/*need_userincludes*/

/********************* See f2py2e/capi_rules.py: usercode *********************/


/* See f2py2e/rules.py */
extern void F_FUNC(ReadParam,READPARAM)(void);
extern void F_FUNC(RndmPack,RNDMPACK)(void);
extern void F_FUNC(GnrtRdii,GNRTRDII)(void);
extern void F_FUNC(RNorm,RNORM)(float*,float*,float*,float*);
extern void F_WRAPPEDFUNC(rinvnorm,RINVNORM)(float*,float*);
extern void F_FUNC(GnrtSite,GNRTSITE)(void);
extern void F_FUNC(GnrtPack,GNRTPACK)(void);
extern void F_FUNC(Output,OUTPUT)(void);
extern void F_FUNC(AlloctCmpt,ALLOCTCMPT)(void);
extern void F_FUNC(InitialCnt,INITIALCNT)(void);
extern void F_FUNC(Allocating,ALLOCATING)(int*,int*);
extern void F_FUNC(Sort,SORT)(void);
extern void F_FUNC(InitialSort,INITIALSORT)(int*);
extern void F_FUNC(FindZmin,FINDZMIN)(int*,int*);
extern void F_FUNC(Reorder,REORDER)(int*,int*);
extern void F_FUNC(Sorting,SORTING)(int*);
extern void F_FUNC(FindXYZ,FINDXYZ)(void);
extern void F_FUNC(Shift1,SHIFT1)(int*,int*,int*,int*);
extern void F_FUNC(Shift2,SHIFT2)(int*,int*,int*,int*);
extern void F_FUNC(Shift3,SHIFT3)(int*,int*,int*,int*);
extern void F_FUNC(Shift4,SHIFT4)(int*,int*,int*,int*);
extern void F_FUNC(ChkOvlp,CHKOVLP)(int*);
extern void F_FUNC(FindZmax,FINDZMAX)(int*);
extern void F_FUNC(Roll1Loc,ROLL1LOC)(void);
extern void F_FUNC(CalR1Loc,CALR1LOC)(int*);
extern void F_FUNC(Roll2Loc,ROLL2LOC)(void);
extern void F_FUNC(CalR2Loc,CALR2LOC)(int*);
extern void F_FUNC(Register,REGISTER)(void);
extern void F_FUNC(ShiftDown,SHIFTDOWN)(void);
extern void F_FUNC(FindLocBC,FINDLOCBC)(int*);
extern void F_FUNC(RollItBC,ROLLITBC)(void);
extern void F_FUNC(ChkBCmpt,CHKBCMPT)(float*,int*);
extern void F_FUNC(FindXYZBC,FINDXYZBC)(float*,int*);
extern void F_FUNC(BCRoll1,BCROLL1)(float*,int*,int*,int*);
extern void F_FUNC(BCRoll2,BCROLL2)(float*,int*,int*,int*);
extern void F_FUNC(BCRoll3,BCROLL3)(float*,int*,int*,int*);
extern void F_FUNC(BCRoll4,BCROLL4)(float*,int*,int*,int*);
extern void F_FUNC(ChkBCOvlp,CHKBCOVLP)(float*,int*,int*);
extern void F_FUNC(CalRLocBC,CALRLOCBC)(int*);
extern void F_FUNC(RelocateBC,RELOCATEBC)(void);
extern void F_FUNC(FindLoc,FINDLOC)(int*);
extern void F_FUNC(RollOn1,ROLLON1)(void);
extern void F_FUNC(ChkCmpt,CHKCMPT)(void);
extern void F_FUNC(SettleRlmt,SETTLERLMT)(void);
extern void F_FUNC(CalRlmtLoc,CALRLMTLOC)(float*,float*,float*);
extern void F_FUNC(RollOn2,ROLLON2)(void);
extern void F_FUNC(VertRoll,VERTROLL)(float*,float*,float*);
extern void F_FUNC(CalRLoc,CALRLOC)(float*,float*,float*,float*,float*,float*,float*);
extern void F_FUNC(TransFwd,TRANSFWD)(float*,float*,float*,float*,float*,float*,float*);
extern void F_FUNC(TransBwd,TRANSBWD)(float*,float*,float*);
extern void F_FUNC(ChkCond,CHKCOND)(void);
extern void F_FUNC(TmpRec,TMPREC)(void);
extern void F_FUNC(LocalShift,LOCALSHIFT)(void);
extern void F_FUNC(ChooseSite,CHOOSESITE)(void);
extern void F_FUNC(Relocate,RELOCATE)(void);
extern void F_FUNC(FinalSet,FINALSET)(void);
/*eof externroutines*/

/******************** See f2py2e/capi_rules.py: usercode1 ********************/


/******************* See f2py2e/cb_rules.py: buildcallback *******************/
/*need_callbacks*/

/*********************** See f2py2e/rules.py: buildapi ***********************/

/********************************* ReadParam *********************************/
static char doc_f2py_rout_test.pyf_ReadParam[] = "\
ReadParam()\n\nWrapper for ``ReadParam``.\
\n";
/* extern void F_FUNC(ReadParam,READPARAM)(void); */
static PyObject *f2py_rout_test.pyf_ReadParam(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.ReadParam",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of ReadParam ******************************/

/********************************** RndmPack **********************************/
static char doc_f2py_rout_test.pyf_RndmPack[] = "\
RndmPack()\n\nWrapper for ``RndmPack``.\
\n";
/* extern void F_FUNC(RndmPack,RNDMPACK)(void); */
static PyObject *f2py_rout_test.pyf_RndmPack(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.RndmPack",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of RndmPack ******************************/

/********************************** GnrtRdii **********************************/
static char doc_f2py_rout_test.pyf_GnrtRdii[] = "\
GnrtRdii()\n\nWrapper for ``GnrtRdii``.\
\n";
/* extern void F_FUNC(GnrtRdii,GNRTRDII)(void); */
static PyObject *f2py_rout_test.pyf_GnrtRdii(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.GnrtRdii",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of GnrtRdii ******************************/

/*********************************** RNorm ***********************************/
static char doc_f2py_rout_test.pyf_RNorm[] = "\
RNorm(Mu,Sigma,Sample,Seed)\n\nWrapper for ``RNorm``.\
\n\nParameters\n----------\n"
"Mu : input float\n"
"Sigma : input float\n"
"Sample : input float\n"
"Seed : input float";
/* extern void F_FUNC(RNorm,RNORM)(float*,float*,float*,float*); */
static PyObject *f2py_rout_test.pyf_RNorm(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float Mu = 0;
  PyObject *Mu_capi = Py_None;
  float Sigma = 0;
  PyObject *Sigma_capi = Py_None;
  float Sample = 0;
  PyObject *Sample_capi = Py_None;
  float Seed = 0;
  PyObject *Seed_capi = Py_None;
  static char *capi_kwlist[] = {"Mu","Sigma","Sample","Seed",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.RNorm",\
    capi_kwlist,&Mu_capi,&Sigma_capi,&Sample_capi,&Seed_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable Seed */
    f2py_success = float_from_pyobj(&Seed,Seed_capi,"test.pyf.RNorm() 4th argument (Seed) can't be converted to float");
  if (f2py_success) {
  /* Processing variable Mu */
    f2py_success = float_from_pyobj(&Mu,Mu_capi,"test.pyf.RNorm() 1st argument (Mu) can't be converted to float");
  if (f2py_success) {
  /* Processing variable Sigma */
    f2py_success = float_from_pyobj(&Sigma,Sigma_capi,"test.pyf.RNorm() 2nd argument (Sigma) can't be converted to float");
  if (f2py_success) {
  /* Processing variable Sample */
    f2py_success = float_from_pyobj(&Sample,Sample_capi,"test.pyf.RNorm() 3rd argument (Sample) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&Mu,&Sigma,&Sample,&Seed);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of Sample*/
  /* End of cleaning variable Sample */
  } /*if (f2py_success) of Sigma*/
  /* End of cleaning variable Sigma */
  } /*if (f2py_success) of Mu*/
  /* End of cleaning variable Mu */
  } /*if (f2py_success) of Seed*/
  /* End of cleaning variable Seed */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of RNorm ********************************/

/********************************** RInvNorm **********************************/
static char doc_f2py_rout_test.pyf_RInvNorm[] = "\
RInvNorm = RInvNorm(P)\n\nWrapper for ``RInvNorm``.\
\n\nParameters\n----------\n"
"P : input float\n"
"\nReturns\n-------\n"
"RInvNorm : float";
/* extern void F_WRAPPEDFUNC(rinvnorm,RINVNORM)(float*,float*); */
static PyObject *f2py_rout_test.pyf_RInvNorm(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float RInvNorm = 0;
  float P = 0;
  PyObject *P_capi = Py_None;
  static char *capi_kwlist[] = {"P",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.RInvNorm",\
    capi_kwlist,&P_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable P */
    f2py_success = float_from_pyobj(&P,P_capi,"test.pyf.RInvNorm() 1st argument (P) can't be converted to float");
  if (f2py_success) {
  /* Processing variable RInvNorm */
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
  (*f2py_func)(&RInvNorm,&P);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("f",RInvNorm);
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  /* End of cleaning variable RInvNorm */
  } /*if (f2py_success) of P*/
  /* End of cleaning variable P */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of RInvNorm ******************************/

/********************************** GnrtSite **********************************/
static char doc_f2py_rout_test.pyf_GnrtSite[] = "\
GnrtSite()\n\nWrapper for ``GnrtSite``.\
\n";
/* extern void F_FUNC(GnrtSite,GNRTSITE)(void); */
static PyObject *f2py_rout_test.pyf_GnrtSite(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.GnrtSite",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of GnrtSite ******************************/

/********************************** GnrtPack **********************************/
static char doc_f2py_rout_test.pyf_GnrtPack[] = "\
GnrtPack()\n\nWrapper for ``GnrtPack``.\
\n";
/* extern void F_FUNC(GnrtPack,GNRTPACK)(void); */
static PyObject *f2py_rout_test.pyf_GnrtPack(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.GnrtPack",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of GnrtPack ******************************/

/*********************************** Output ***********************************/
static char doc_f2py_rout_test.pyf_Output[] = "\
Output()\n\nWrapper for ``Output``.\
\n";
/* extern void F_FUNC(Output,OUTPUT)(void); */
static PyObject *f2py_rout_test.pyf_Output(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.Output",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of Output *******************************/

/********************************* AlloctCmpt *********************************/
static char doc_f2py_rout_test.pyf_AlloctCmpt[] = "\
AlloctCmpt()\n\nWrapper for ``AlloctCmpt``.\
\n";
/* extern void F_FUNC(AlloctCmpt,ALLOCTCMPT)(void); */
static PyObject *f2py_rout_test.pyf_AlloctCmpt(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.AlloctCmpt",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of AlloctCmpt *****************************/

/********************************* InitialCnt *********************************/
static char doc_f2py_rout_test.pyf_InitialCnt[] = "\
InitialCnt()\n\nWrapper for ``InitialCnt``.\
\n";
/* extern void F_FUNC(InitialCnt,INITIALCNT)(void); */
static PyObject *f2py_rout_test.pyf_InitialCnt(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.InitialCnt",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of InitialCnt *****************************/

/********************************* Allocating *********************************/
static char doc_f2py_rout_test.pyf_Allocating[] = "\
Allocating(i,mz)\n\nWrapper for ``Allocating``.\
\n\nParameters\n----------\n"
"i : input int\n"
"mz : input int";
/* extern void F_FUNC(Allocating,ALLOCATING)(int*,int*); */
static PyObject *f2py_rout_test.pyf_Allocating(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int i = 0;
  PyObject *i_capi = Py_None;
  int mz = 0;
  PyObject *mz_capi = Py_None;
  static char *capi_kwlist[] = {"i","mz",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:test.pyf.Allocating",\
    capi_kwlist,&i_capi,&mz_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable i */
    f2py_success = int_from_pyobj(&i,i_capi,"test.pyf.Allocating() 1st argument (i) can't be converted to int");
  if (f2py_success) {
  /* Processing variable mz */
    f2py_success = int_from_pyobj(&mz,mz_capi,"test.pyf.Allocating() 2nd argument (mz) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&i,&mz);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of mz*/
  /* End of cleaning variable mz */
  } /*if (f2py_success) of i*/
  /* End of cleaning variable i */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of Allocating *****************************/

/************************************ Sort ************************************/
static char doc_f2py_rout_test.pyf_Sort[] = "\
Sort()\n\nWrapper for ``Sort``.\
\n";
/* extern void F_FUNC(Sort,SORT)(void); */
static PyObject *f2py_rout_test.pyf_Sort(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.Sort",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************** end of Sort ********************************/

/******************************** InitialSort ********************************/
static char doc_f2py_rout_test.pyf_InitialSort[] = "\
InitialSort(lz)\n\nWrapper for ``InitialSort``.\
\n\nParameters\n----------\n"
"lz : input int";
/* extern void F_FUNC(InitialSort,INITIALSORT)(int*); */
static PyObject *f2py_rout_test.pyf_InitialSort(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int lz = 0;
  PyObject *lz_capi = Py_None;
  static char *capi_kwlist[] = {"lz",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.InitialSort",\
    capi_kwlist,&lz_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable lz */
    f2py_success = int_from_pyobj(&lz,lz_capi,"test.pyf.InitialSort() 1st argument (lz) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&lz);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of lz*/
  /* End of cleaning variable lz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of InitialSort *****************************/

/********************************** FindZmin **********************************/
static char doc_f2py_rout_test.pyf_FindZmin[] = "\
FindZmin(ic1,ncpart1)\n\nWrapper for ``FindZmin``.\
\n\nParameters\n----------\n"
"ic1 : input int\n"
"ncpart1 : input int";
/* extern void F_FUNC(FindZmin,FINDZMIN)(int*,int*); */
static PyObject *f2py_rout_test.pyf_FindZmin(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int ic1 = 0;
  PyObject *ic1_capi = Py_None;
  int ncpart1 = 0;
  PyObject *ncpart1_capi = Py_None;
  static char *capi_kwlist[] = {"ic1","ncpart1",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:test.pyf.FindZmin",\
    capi_kwlist,&ic1_capi,&ncpart1_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable ic1 */
    f2py_success = int_from_pyobj(&ic1,ic1_capi,"test.pyf.FindZmin() 1st argument (ic1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ncpart1 */
    f2py_success = int_from_pyobj(&ncpart1,ncpart1_capi,"test.pyf.FindZmin() 2nd argument (ncpart1) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&ic1,&ncpart1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of ncpart1*/
  /* End of cleaning variable ncpart1 */
  } /*if (f2py_success) of ic1*/
  /* End of cleaning variable ic1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of FindZmin ******************************/

/********************************** Reorder **********************************/
static char doc_f2py_rout_test.pyf_Reorder[] = "\
Reorder(ic1,ncpart1)\n\nWrapper for ``Reorder``.\
\n\nParameters\n----------\n"
"ic1 : input int\n"
"ncpart1 : input int";
/* extern void F_FUNC(Reorder,REORDER)(int*,int*); */
static PyObject *f2py_rout_test.pyf_Reorder(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int ic1 = 0;
  PyObject *ic1_capi = Py_None;
  int ncpart1 = 0;
  PyObject *ncpart1_capi = Py_None;
  static char *capi_kwlist[] = {"ic1","ncpart1",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:test.pyf.Reorder",\
    capi_kwlist,&ic1_capi,&ncpart1_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable ic1 */
    f2py_success = int_from_pyobj(&ic1,ic1_capi,"test.pyf.Reorder() 1st argument (ic1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable ncpart1 */
    f2py_success = int_from_pyobj(&ncpart1,ncpart1_capi,"test.pyf.Reorder() 2nd argument (ncpart1) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&ic1,&ncpart1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of ncpart1*/
  /* End of cleaning variable ncpart1 */
  } /*if (f2py_success) of ic1*/
  /* End of cleaning variable ic1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of Reorder *******************************/

/********************************** Sorting **********************************/
static char doc_f2py_rout_test.pyf_Sorting[] = "\
Sorting(lz)\n\nWrapper for ``Sorting``.\
\n\nParameters\n----------\n"
"lz : input int";
/* extern void F_FUNC(Sorting,SORTING)(int*); */
static PyObject *f2py_rout_test.pyf_Sorting(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int lz = 0;
  PyObject *lz_capi = Py_None;
  static char *capi_kwlist[] = {"lz",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.Sorting",\
    capi_kwlist,&lz_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable lz */
    f2py_success = int_from_pyobj(&lz,lz_capi,"test.pyf.Sorting() 1st argument (lz) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&lz);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of lz*/
  /* End of cleaning variable lz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of Sorting *******************************/

/********************************** FindXYZ **********************************/
static char doc_f2py_rout_test.pyf_FindXYZ[] = "\
FindXYZ()\n\nWrapper for ``FindXYZ``.\
\n";
/* extern void F_FUNC(FindXYZ,FINDXYZ)(void); */
static PyObject *f2py_rout_test.pyf_FindXYZ(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.FindXYZ",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of FindXYZ *******************************/

/*********************************** Shift1 ***********************************/
static char doc_f2py_rout_test.pyf_Shift1[] = "\
Shift1(i1xx,jyy,kzz,mflag)\n\nWrapper for ``Shift1``.\
\n\nParameters\n----------\n"
"i1xx : input int\n"
"jyy : input int\n"
"kzz : input int\n"
"mflag : input int";
/* extern void F_FUNC(Shift1,SHIFT1)(int*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_Shift1(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int i1xx = 0;
  PyObject *i1xx_capi = Py_None;
  int jyy = 0;
  PyObject *jyy_capi = Py_None;
  int kzz = 0;
  PyObject *kzz_capi = Py_None;
  int mflag = 0;
  PyObject *mflag_capi = Py_None;
  static char *capi_kwlist[] = {"i1xx","jyy","kzz","mflag",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.Shift1",\
    capi_kwlist,&i1xx_capi,&jyy_capi,&kzz_capi,&mflag_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable i1xx */
    f2py_success = int_from_pyobj(&i1xx,i1xx_capi,"test.pyf.Shift1() 1st argument (i1xx) can't be converted to int");
  if (f2py_success) {
  /* Processing variable jyy */
    f2py_success = int_from_pyobj(&jyy,jyy_capi,"test.pyf.Shift1() 2nd argument (jyy) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzz */
    f2py_success = int_from_pyobj(&kzz,kzz_capi,"test.pyf.Shift1() 3rd argument (kzz) can't be converted to int");
  if (f2py_success) {
  /* Processing variable mflag */
    f2py_success = int_from_pyobj(&mflag,mflag_capi,"test.pyf.Shift1() 4th argument (mflag) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&i1xx,&jyy,&kzz,&mflag);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of mflag*/
  /* End of cleaning variable mflag */
  } /*if (f2py_success) of kzz*/
  /* End of cleaning variable kzz */
  } /*if (f2py_success) of jyy*/
  /* End of cleaning variable jyy */
  } /*if (f2py_success) of i1xx*/
  /* End of cleaning variable i1xx */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of Shift1 *******************************/

/*********************************** Shift2 ***********************************/
static char doc_f2py_rout_test.pyf_Shift2[] = "\
Shift2(i1xx,jyy,kzz,mflag)\n\nWrapper for ``Shift2``.\
\n\nParameters\n----------\n"
"i1xx : input int\n"
"jyy : input int\n"
"kzz : input int\n"
"mflag : input int";
/* extern void F_FUNC(Shift2,SHIFT2)(int*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_Shift2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int i1xx = 0;
  PyObject *i1xx_capi = Py_None;
  int jyy = 0;
  PyObject *jyy_capi = Py_None;
  int kzz = 0;
  PyObject *kzz_capi = Py_None;
  int mflag = 0;
  PyObject *mflag_capi = Py_None;
  static char *capi_kwlist[] = {"i1xx","jyy","kzz","mflag",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.Shift2",\
    capi_kwlist,&i1xx_capi,&jyy_capi,&kzz_capi,&mflag_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable i1xx */
    f2py_success = int_from_pyobj(&i1xx,i1xx_capi,"test.pyf.Shift2() 1st argument (i1xx) can't be converted to int");
  if (f2py_success) {
  /* Processing variable jyy */
    f2py_success = int_from_pyobj(&jyy,jyy_capi,"test.pyf.Shift2() 2nd argument (jyy) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzz */
    f2py_success = int_from_pyobj(&kzz,kzz_capi,"test.pyf.Shift2() 3rd argument (kzz) can't be converted to int");
  if (f2py_success) {
  /* Processing variable mflag */
    f2py_success = int_from_pyobj(&mflag,mflag_capi,"test.pyf.Shift2() 4th argument (mflag) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&i1xx,&jyy,&kzz,&mflag);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of mflag*/
  /* End of cleaning variable mflag */
  } /*if (f2py_success) of kzz*/
  /* End of cleaning variable kzz */
  } /*if (f2py_success) of jyy*/
  /* End of cleaning variable jyy */
  } /*if (f2py_success) of i1xx*/
  /* End of cleaning variable i1xx */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of Shift2 *******************************/

/*********************************** Shift3 ***********************************/
static char doc_f2py_rout_test.pyf_Shift3[] = "\
Shift3(i1xx,jyy,kzz,mflag)\n\nWrapper for ``Shift3``.\
\n\nParameters\n----------\n"
"i1xx : input int\n"
"jyy : input int\n"
"kzz : input int\n"
"mflag : input int";
/* extern void F_FUNC(Shift3,SHIFT3)(int*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_Shift3(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int i1xx = 0;
  PyObject *i1xx_capi = Py_None;
  int jyy = 0;
  PyObject *jyy_capi = Py_None;
  int kzz = 0;
  PyObject *kzz_capi = Py_None;
  int mflag = 0;
  PyObject *mflag_capi = Py_None;
  static char *capi_kwlist[] = {"i1xx","jyy","kzz","mflag",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.Shift3",\
    capi_kwlist,&i1xx_capi,&jyy_capi,&kzz_capi,&mflag_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable i1xx */
    f2py_success = int_from_pyobj(&i1xx,i1xx_capi,"test.pyf.Shift3() 1st argument (i1xx) can't be converted to int");
  if (f2py_success) {
  /* Processing variable jyy */
    f2py_success = int_from_pyobj(&jyy,jyy_capi,"test.pyf.Shift3() 2nd argument (jyy) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzz */
    f2py_success = int_from_pyobj(&kzz,kzz_capi,"test.pyf.Shift3() 3rd argument (kzz) can't be converted to int");
  if (f2py_success) {
  /* Processing variable mflag */
    f2py_success = int_from_pyobj(&mflag,mflag_capi,"test.pyf.Shift3() 4th argument (mflag) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&i1xx,&jyy,&kzz,&mflag);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of mflag*/
  /* End of cleaning variable mflag */
  } /*if (f2py_success) of kzz*/
  /* End of cleaning variable kzz */
  } /*if (f2py_success) of jyy*/
  /* End of cleaning variable jyy */
  } /*if (f2py_success) of i1xx*/
  /* End of cleaning variable i1xx */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of Shift3 *******************************/

/*********************************** Shift4 ***********************************/
static char doc_f2py_rout_test.pyf_Shift4[] = "\
Shift4(i1xx,jyy,kzz,mflag)\n\nWrapper for ``Shift4``.\
\n\nParameters\n----------\n"
"i1xx : input int\n"
"jyy : input int\n"
"kzz : input int\n"
"mflag : input int";
/* extern void F_FUNC(Shift4,SHIFT4)(int*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_Shift4(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int i1xx = 0;
  PyObject *i1xx_capi = Py_None;
  int jyy = 0;
  PyObject *jyy_capi = Py_None;
  int kzz = 0;
  PyObject *kzz_capi = Py_None;
  int mflag = 0;
  PyObject *mflag_capi = Py_None;
  static char *capi_kwlist[] = {"i1xx","jyy","kzz","mflag",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.Shift4",\
    capi_kwlist,&i1xx_capi,&jyy_capi,&kzz_capi,&mflag_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable i1xx */
    f2py_success = int_from_pyobj(&i1xx,i1xx_capi,"test.pyf.Shift4() 1st argument (i1xx) can't be converted to int");
  if (f2py_success) {
  /* Processing variable jyy */
    f2py_success = int_from_pyobj(&jyy,jyy_capi,"test.pyf.Shift4() 2nd argument (jyy) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzz */
    f2py_success = int_from_pyobj(&kzz,kzz_capi,"test.pyf.Shift4() 3rd argument (kzz) can't be converted to int");
  if (f2py_success) {
  /* Processing variable mflag */
    f2py_success = int_from_pyobj(&mflag,mflag_capi,"test.pyf.Shift4() 4th argument (mflag) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&i1xx,&jyy,&kzz,&mflag);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of mflag*/
  /* End of cleaning variable mflag */
  } /*if (f2py_success) of kzz*/
  /* End of cleaning variable kzz */
  } /*if (f2py_success) of jyy*/
  /* End of cleaning variable jyy */
  } /*if (f2py_success) of i1xx*/
  /* End of cleaning variable i1xx */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of Shift4 *******************************/

/********************************** ChkOvlp **********************************/
static char doc_f2py_rout_test.pyf_ChkOvlp[] = "\
ChkOvlp(mflag)\n\nWrapper for ``ChkOvlp``.\
\n\nParameters\n----------\n"
"mflag : input int";
/* extern void F_FUNC(ChkOvlp,CHKOVLP)(int*); */
static PyObject *f2py_rout_test.pyf_ChkOvlp(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int mflag = 0;
  PyObject *mflag_capi = Py_None;
  static char *capi_kwlist[] = {"mflag",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.ChkOvlp",\
    capi_kwlist,&mflag_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mflag */
    f2py_success = int_from_pyobj(&mflag,mflag_capi,"test.pyf.ChkOvlp() 1st argument (mflag) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&mflag);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of mflag*/
  /* End of cleaning variable mflag */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of ChkOvlp *******************************/

/********************************** FindZmax **********************************/
static char doc_f2py_rout_test.pyf_FindZmax[] = "\
FindZmax(mflag)\n\nWrapper for ``FindZmax``.\
\n\nParameters\n----------\n"
"mflag : input int";
/* extern void F_FUNC(FindZmax,FINDZMAX)(int*); */
static PyObject *f2py_rout_test.pyf_FindZmax(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int mflag = 0;
  PyObject *mflag_capi = Py_None;
  static char *capi_kwlist[] = {"mflag",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.FindZmax",\
    capi_kwlist,&mflag_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable mflag */
    f2py_success = int_from_pyobj(&mflag,mflag_capi,"test.pyf.FindZmax() 1st argument (mflag) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&mflag);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of mflag*/
  /* End of cleaning variable mflag */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of FindZmax ******************************/

/********************************** Roll1Loc **********************************/
static char doc_f2py_rout_test.pyf_Roll1Loc[] = "\
Roll1Loc()\n\nWrapper for ``Roll1Loc``.\
\n";
/* extern void F_FUNC(Roll1Loc,ROLL1LOC)(void); */
static PyObject *f2py_rout_test.pyf_Roll1Loc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.Roll1Loc",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of Roll1Loc ******************************/

/********************************** CalR1Loc **********************************/
static char doc_f2py_rout_test.pyf_CalR1Loc[] = "\
CalR1Loc(icst)\n\nWrapper for ``CalR1Loc``.\
\n\nParameters\n----------\n"
"icst : input int";
/* extern void F_FUNC(CalR1Loc,CALR1LOC)(int*); */
static PyObject *f2py_rout_test.pyf_CalR1Loc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int icst = 0;
  PyObject *icst_capi = Py_None;
  static char *capi_kwlist[] = {"icst",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.CalR1Loc",\
    capi_kwlist,&icst_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable icst */
    f2py_success = int_from_pyobj(&icst,icst_capi,"test.pyf.CalR1Loc() 1st argument (icst) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&icst);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of icst*/
  /* End of cleaning variable icst */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of CalR1Loc ******************************/

/********************************** Roll2Loc **********************************/
static char doc_f2py_rout_test.pyf_Roll2Loc[] = "\
Roll2Loc()\n\nWrapper for ``Roll2Loc``.\
\n";
/* extern void F_FUNC(Roll2Loc,ROLL2LOC)(void); */
static PyObject *f2py_rout_test.pyf_Roll2Loc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.Roll2Loc",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of Roll2Loc ******************************/

/********************************** CalR2Loc **********************************/
static char doc_f2py_rout_test.pyf_CalR2Loc[] = "\
CalR2Loc(icst)\n\nWrapper for ``CalR2Loc``.\
\n\nParameters\n----------\n"
"icst : input int";
/* extern void F_FUNC(CalR2Loc,CALR2LOC)(int*); */
static PyObject *f2py_rout_test.pyf_CalR2Loc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int icst = 0;
  PyObject *icst_capi = Py_None;
  static char *capi_kwlist[] = {"icst",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.CalR2Loc",\
    capi_kwlist,&icst_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable icst */
    f2py_success = int_from_pyobj(&icst,icst_capi,"test.pyf.CalR2Loc() 1st argument (icst) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&icst);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of icst*/
  /* End of cleaning variable icst */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of CalR2Loc ******************************/

/********************************** Register **********************************/
static char doc_f2py_rout_test.pyf_Register[] = "\
Register()\n\nWrapper for ``Register``.\
\n";
/* extern void F_FUNC(Register,REGISTER)(void); */
static PyObject *f2py_rout_test.pyf_Register(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.Register",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of Register ******************************/

/********************************* ShiftDown *********************************/
static char doc_f2py_rout_test.pyf_ShiftDown[] = "\
ShiftDown()\n\nWrapper for ``ShiftDown``.\
\n";
/* extern void F_FUNC(ShiftDown,SHIFTDOWN)(void); */
static PyObject *f2py_rout_test.pyf_ShiftDown(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.ShiftDown",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of ShiftDown ******************************/

/********************************* FindLocBC *********************************/
static char doc_f2py_rout_test.pyf_FindLocBC[] = "\
FindLocBC(lz)\n\nWrapper for ``FindLocBC``.\
\n\nParameters\n----------\n"
"lz : input int";
/* extern void F_FUNC(FindLocBC,FINDLOCBC)(int*); */
static PyObject *f2py_rout_test.pyf_FindLocBC(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int lz = 0;
  PyObject *lz_capi = Py_None;
  static char *capi_kwlist[] = {"lz",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.FindLocBC",\
    capi_kwlist,&lz_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable lz */
    f2py_success = int_from_pyobj(&lz,lz_capi,"test.pyf.FindLocBC() 1st argument (lz) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&lz);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of lz*/
  /* End of cleaning variable lz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of FindLocBC ******************************/

/********************************** RollItBC **********************************/
static char doc_f2py_rout_test.pyf_RollItBC[] = "\
RollItBC()\n\nWrapper for ``RollItBC``.\
\n";
/* extern void F_FUNC(RollItBC,ROLLITBC)(void); */
static PyObject *f2py_rout_test.pyf_RollItBC(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.RollItBC",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of RollItBC ******************************/

/********************************** ChkBCmpt **********************************/
static char doc_f2py_rout_test.pyf_ChkBCmpt[] = "\
ChkBCmpt(p1,lp1)\n\nWrapper for ``ChkBCmpt``.\
\n\nParameters\n----------\n"
"p1 : input float\n"
"lp1 : input int";
/* extern void F_FUNC(ChkBCmpt,CHKBCMPT)(float*,int*); */
static PyObject *f2py_rout_test.pyf_ChkBCmpt(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float p1 = 0;
  PyObject *p1_capi = Py_None;
  int lp1 = 0;
  PyObject *lp1_capi = Py_None;
  static char *capi_kwlist[] = {"p1","lp1",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:test.pyf.ChkBCmpt",\
    capi_kwlist,&p1_capi,&lp1_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p1 */
    f2py_success = float_from_pyobj(&p1,p1_capi,"test.pyf.ChkBCmpt() 1st argument (p1) can't be converted to float");
  if (f2py_success) {
  /* Processing variable lp1 */
    f2py_success = int_from_pyobj(&lp1,lp1_capi,"test.pyf.ChkBCmpt() 2nd argument (lp1) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&p1,&lp1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of lp1*/
  /* End of cleaning variable lp1 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of ChkBCmpt ******************************/

/********************************* FindXYZBC *********************************/
static char doc_f2py_rout_test.pyf_FindXYZBC[] = "\
FindXYZBC(p1,lp1)\n\nWrapper for ``FindXYZBC``.\
\n\nParameters\n----------\n"
"p1 : input float\n"
"lp1 : input int";
/* extern void F_FUNC(FindXYZBC,FINDXYZBC)(float*,int*); */
static PyObject *f2py_rout_test.pyf_FindXYZBC(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float p1 = 0;
  PyObject *p1_capi = Py_None;
  int lp1 = 0;
  PyObject *lp1_capi = Py_None;
  static char *capi_kwlist[] = {"p1","lp1",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OO:test.pyf.FindXYZBC",\
    capi_kwlist,&p1_capi,&lp1_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p1 */
    f2py_success = float_from_pyobj(&p1,p1_capi,"test.pyf.FindXYZBC() 1st argument (p1) can't be converted to float");
  if (f2py_success) {
  /* Processing variable lp1 */
    f2py_success = int_from_pyobj(&lp1,lp1_capi,"test.pyf.FindXYZBC() 2nd argument (lp1) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&p1,&lp1);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of lp1*/
  /* End of cleaning variable lp1 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of FindXYZBC ******************************/

/********************************** BCRoll1 **********************************/
static char doc_f2py_rout_test.pyf_BCRoll1[] = "\
BCRoll1(p1,lp1,lpp,kzp)\n\nWrapper for ``BCRoll1``.\
\n\nParameters\n----------\n"
"p1 : input float\n"
"lp1 : input int\n"
"lpp : input int\n"
"kzp : input int";
/* extern void F_FUNC(BCRoll1,BCROLL1)(float*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_BCRoll1(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float p1 = 0;
  PyObject *p1_capi = Py_None;
  int lp1 = 0;
  PyObject *lp1_capi = Py_None;
  int lpp = 0;
  PyObject *lpp_capi = Py_None;
  int kzp = 0;
  PyObject *kzp_capi = Py_None;
  static char *capi_kwlist[] = {"p1","lp1","lpp","kzp",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.BCRoll1",\
    capi_kwlist,&p1_capi,&lp1_capi,&lpp_capi,&kzp_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p1 */
    f2py_success = float_from_pyobj(&p1,p1_capi,"test.pyf.BCRoll1() 1st argument (p1) can't be converted to float");
  if (f2py_success) {
  /* Processing variable lp1 */
    f2py_success = int_from_pyobj(&lp1,lp1_capi,"test.pyf.BCRoll1() 2nd argument (lp1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable lpp */
    f2py_success = int_from_pyobj(&lpp,lpp_capi,"test.pyf.BCRoll1() 3rd argument (lpp) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzp */
    f2py_success = int_from_pyobj(&kzp,kzp_capi,"test.pyf.BCRoll1() 4th argument (kzp) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&p1,&lp1,&lpp,&kzp);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of kzp*/
  /* End of cleaning variable kzp */
  } /*if (f2py_success) of lpp*/
  /* End of cleaning variable lpp */
  } /*if (f2py_success) of lp1*/
  /* End of cleaning variable lp1 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of BCRoll1 *******************************/

/********************************** BCRoll2 **********************************/
static char doc_f2py_rout_test.pyf_BCRoll2[] = "\
BCRoll2(p1,lp1,lpp,kzp)\n\nWrapper for ``BCRoll2``.\
\n\nParameters\n----------\n"
"p1 : input float\n"
"lp1 : input int\n"
"lpp : input int\n"
"kzp : input int";
/* extern void F_FUNC(BCRoll2,BCROLL2)(float*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_BCRoll2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float p1 = 0;
  PyObject *p1_capi = Py_None;
  int lp1 = 0;
  PyObject *lp1_capi = Py_None;
  int lpp = 0;
  PyObject *lpp_capi = Py_None;
  int kzp = 0;
  PyObject *kzp_capi = Py_None;
  static char *capi_kwlist[] = {"p1","lp1","lpp","kzp",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.BCRoll2",\
    capi_kwlist,&p1_capi,&lp1_capi,&lpp_capi,&kzp_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p1 */
    f2py_success = float_from_pyobj(&p1,p1_capi,"test.pyf.BCRoll2() 1st argument (p1) can't be converted to float");
  if (f2py_success) {
  /* Processing variable lp1 */
    f2py_success = int_from_pyobj(&lp1,lp1_capi,"test.pyf.BCRoll2() 2nd argument (lp1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable lpp */
    f2py_success = int_from_pyobj(&lpp,lpp_capi,"test.pyf.BCRoll2() 3rd argument (lpp) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzp */
    f2py_success = int_from_pyobj(&kzp,kzp_capi,"test.pyf.BCRoll2() 4th argument (kzp) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&p1,&lp1,&lpp,&kzp);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of kzp*/
  /* End of cleaning variable kzp */
  } /*if (f2py_success) of lpp*/
  /* End of cleaning variable lpp */
  } /*if (f2py_success) of lp1*/
  /* End of cleaning variable lp1 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of BCRoll2 *******************************/

/********************************** BCRoll3 **********************************/
static char doc_f2py_rout_test.pyf_BCRoll3[] = "\
BCRoll3(p1,lp1,lpp,kzp)\n\nWrapper for ``BCRoll3``.\
\n\nParameters\n----------\n"
"p1 : input float\n"
"lp1 : input int\n"
"lpp : input int\n"
"kzp : input int";
/* extern void F_FUNC(BCRoll3,BCROLL3)(float*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_BCRoll3(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float p1 = 0;
  PyObject *p1_capi = Py_None;
  int lp1 = 0;
  PyObject *lp1_capi = Py_None;
  int lpp = 0;
  PyObject *lpp_capi = Py_None;
  int kzp = 0;
  PyObject *kzp_capi = Py_None;
  static char *capi_kwlist[] = {"p1","lp1","lpp","kzp",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.BCRoll3",\
    capi_kwlist,&p1_capi,&lp1_capi,&lpp_capi,&kzp_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p1 */
    f2py_success = float_from_pyobj(&p1,p1_capi,"test.pyf.BCRoll3() 1st argument (p1) can't be converted to float");
  if (f2py_success) {
  /* Processing variable lp1 */
    f2py_success = int_from_pyobj(&lp1,lp1_capi,"test.pyf.BCRoll3() 2nd argument (lp1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable lpp */
    f2py_success = int_from_pyobj(&lpp,lpp_capi,"test.pyf.BCRoll3() 3rd argument (lpp) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzp */
    f2py_success = int_from_pyobj(&kzp,kzp_capi,"test.pyf.BCRoll3() 4th argument (kzp) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&p1,&lp1,&lpp,&kzp);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of kzp*/
  /* End of cleaning variable kzp */
  } /*if (f2py_success) of lpp*/
  /* End of cleaning variable lpp */
  } /*if (f2py_success) of lp1*/
  /* End of cleaning variable lp1 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of BCRoll3 *******************************/

/********************************** BCRoll4 **********************************/
static char doc_f2py_rout_test.pyf_BCRoll4[] = "\
BCRoll4(p1,lp1,lpp,kzp)\n\nWrapper for ``BCRoll4``.\
\n\nParameters\n----------\n"
"p1 : input float\n"
"lp1 : input int\n"
"lpp : input int\n"
"kzp : input int";
/* extern void F_FUNC(BCRoll4,BCROLL4)(float*,int*,int*,int*); */
static PyObject *f2py_rout_test.pyf_BCRoll4(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float p1 = 0;
  PyObject *p1_capi = Py_None;
  int lp1 = 0;
  PyObject *lp1_capi = Py_None;
  int lpp = 0;
  PyObject *lpp_capi = Py_None;
  int kzp = 0;
  PyObject *kzp_capi = Py_None;
  static char *capi_kwlist[] = {"p1","lp1","lpp","kzp",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOO:test.pyf.BCRoll4",\
    capi_kwlist,&p1_capi,&lp1_capi,&lpp_capi,&kzp_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p1 */
    f2py_success = float_from_pyobj(&p1,p1_capi,"test.pyf.BCRoll4() 1st argument (p1) can't be converted to float");
  if (f2py_success) {
  /* Processing variable lp1 */
    f2py_success = int_from_pyobj(&lp1,lp1_capi,"test.pyf.BCRoll4() 2nd argument (lp1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable lpp */
    f2py_success = int_from_pyobj(&lpp,lpp_capi,"test.pyf.BCRoll4() 3rd argument (lpp) can't be converted to int");
  if (f2py_success) {
  /* Processing variable kzp */
    f2py_success = int_from_pyobj(&kzp,kzp_capi,"test.pyf.BCRoll4() 4th argument (kzp) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&p1,&lp1,&lpp,&kzp);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of kzp*/
  /* End of cleaning variable kzp */
  } /*if (f2py_success) of lpp*/
  /* End of cleaning variable lpp */
  } /*if (f2py_success) of lp1*/
  /* End of cleaning variable lp1 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of BCRoll4 *******************************/

/********************************* ChkBCOvlp *********************************/
static char doc_f2py_rout_test.pyf_ChkBCOvlp[] = "\
ChkBCOvlp(p1,lp1,lp)\n\nWrapper for ``ChkBCOvlp``.\
\n\nParameters\n----------\n"
"p1 : input float\n"
"lp1 : input int\n"
"lp : input int";
/* extern void F_FUNC(ChkBCOvlp,CHKBCOVLP)(float*,int*,int*); */
static PyObject *f2py_rout_test.pyf_ChkBCOvlp(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,int*,int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float p1 = 0;
  PyObject *p1_capi = Py_None;
  int lp1 = 0;
  PyObject *lp1_capi = Py_None;
  int lp = 0;
  PyObject *lp_capi = Py_None;
  static char *capi_kwlist[] = {"p1","lp1","lp",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:test.pyf.ChkBCOvlp",\
    capi_kwlist,&p1_capi,&lp1_capi,&lp_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable p1 */
    f2py_success = float_from_pyobj(&p1,p1_capi,"test.pyf.ChkBCOvlp() 1st argument (p1) can't be converted to float");
  if (f2py_success) {
  /* Processing variable lp1 */
    f2py_success = int_from_pyobj(&lp1,lp1_capi,"test.pyf.ChkBCOvlp() 2nd argument (lp1) can't be converted to int");
  if (f2py_success) {
  /* Processing variable lp */
    f2py_success = int_from_pyobj(&lp,lp_capi,"test.pyf.ChkBCOvlp() 3rd argument (lp) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&p1,&lp1,&lp);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of lp*/
  /* End of cleaning variable lp */
  } /*if (f2py_success) of lp1*/
  /* End of cleaning variable lp1 */
  } /*if (f2py_success) of p1*/
  /* End of cleaning variable p1 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of ChkBCOvlp ******************************/

/********************************* CalRLocBC *********************************/
static char doc_f2py_rout_test.pyf_CalRLocBC[] = "\
CalRLocBC(icst)\n\nWrapper for ``CalRLocBC``.\
\n\nParameters\n----------\n"
"icst : input int";
/* extern void F_FUNC(CalRLocBC,CALRLOCBC)(int*); */
static PyObject *f2py_rout_test.pyf_CalRLocBC(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int icst = 0;
  PyObject *icst_capi = Py_None;
  static char *capi_kwlist[] = {"icst",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.CalRLocBC",\
    capi_kwlist,&icst_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable icst */
    f2py_success = int_from_pyobj(&icst,icst_capi,"test.pyf.CalRLocBC() 1st argument (icst) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&icst);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of icst*/
  /* End of cleaning variable icst */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of CalRLocBC ******************************/

/********************************* RelocateBC *********************************/
static char doc_f2py_rout_test.pyf_RelocateBC[] = "\
RelocateBC()\n\nWrapper for ``RelocateBC``.\
\n";
/* extern void F_FUNC(RelocateBC,RELOCATEBC)(void); */
static PyObject *f2py_rout_test.pyf_RelocateBC(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.RelocateBC",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of RelocateBC *****************************/

/********************************** FindLoc **********************************/
static char doc_f2py_rout_test.pyf_FindLoc[] = "\
FindLoc(lz)\n\nWrapper for ``FindLoc``.\
\n\nParameters\n----------\n"
"lz : input int";
/* extern void F_FUNC(FindLoc,FINDLOC)(int*); */
static PyObject *f2py_rout_test.pyf_FindLoc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(int*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  int lz = 0;
  PyObject *lz_capi = Py_None;
  static char *capi_kwlist[] = {"lz",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "O:test.pyf.FindLoc",\
    capi_kwlist,&lz_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable lz */
    f2py_success = int_from_pyobj(&lz,lz_capi,"test.pyf.FindLoc() 1st argument (lz) can't be converted to int");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&lz);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of lz*/
  /* End of cleaning variable lz */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of FindLoc *******************************/

/********************************** RollOn1 **********************************/
static char doc_f2py_rout_test.pyf_RollOn1[] = "\
RollOn1()\n\nWrapper for ``RollOn1``.\
\n";
/* extern void F_FUNC(RollOn1,ROLLON1)(void); */
static PyObject *f2py_rout_test.pyf_RollOn1(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.RollOn1",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of RollOn1 *******************************/

/********************************** ChkCmpt **********************************/
static char doc_f2py_rout_test.pyf_ChkCmpt[] = "\
ChkCmpt()\n\nWrapper for ``ChkCmpt``.\
\n";
/* extern void F_FUNC(ChkCmpt,CHKCMPT)(void); */
static PyObject *f2py_rout_test.pyf_ChkCmpt(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.ChkCmpt",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of ChkCmpt *******************************/

/********************************* SettleRlmt *********************************/
static char doc_f2py_rout_test.pyf_SettleRlmt[] = "\
SettleRlmt()\n\nWrapper for ``SettleRlmt``.\
\n";
/* extern void F_FUNC(SettleRlmt,SETTLERLMT)(void); */
static PyObject *f2py_rout_test.pyf_SettleRlmt(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.SettleRlmt",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of SettleRlmt *****************************/

/********************************* CalRlmtLoc *********************************/
static char doc_f2py_rout_test.pyf_CalRlmtLoc[] = "\
CalRlmtLoc(alpha,alpha2,alpha3)\n\nWrapper for ``CalRlmtLoc``.\
\n\nParameters\n----------\n"
"alpha : input float\n"
"alpha2 : input float\n"
"alpha3 : input float";
/* extern void F_FUNC(CalRlmtLoc,CALRLMTLOC)(float*,float*,float*); */
static PyObject *f2py_rout_test.pyf_CalRlmtLoc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float alpha = 0;
  PyObject *alpha_capi = Py_None;
  float alpha2 = 0;
  PyObject *alpha2_capi = Py_None;
  float alpha3 = 0;
  PyObject *alpha3_capi = Py_None;
  static char *capi_kwlist[] = {"alpha","alpha2","alpha3",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:test.pyf.CalRlmtLoc",\
    capi_kwlist,&alpha_capi,&alpha2_capi,&alpha3_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable alpha */
    f2py_success = float_from_pyobj(&alpha,alpha_capi,"test.pyf.CalRlmtLoc() 1st argument (alpha) can't be converted to float");
  if (f2py_success) {
  /* Processing variable alpha2 */
    f2py_success = float_from_pyobj(&alpha2,alpha2_capi,"test.pyf.CalRlmtLoc() 2nd argument (alpha2) can't be converted to float");
  if (f2py_success) {
  /* Processing variable alpha3 */
    f2py_success = float_from_pyobj(&alpha3,alpha3_capi,"test.pyf.CalRlmtLoc() 3rd argument (alpha3) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&alpha,&alpha2,&alpha3);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of alpha3*/
  /* End of cleaning variable alpha3 */
  } /*if (f2py_success) of alpha2*/
  /* End of cleaning variable alpha2 */
  } /*if (f2py_success) of alpha*/
  /* End of cleaning variable alpha */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of CalRlmtLoc *****************************/

/********************************** RollOn2 **********************************/
static char doc_f2py_rout_test.pyf_RollOn2[] = "\
RollOn2()\n\nWrapper for ``RollOn2``.\
\n";
/* extern void F_FUNC(RollOn2,ROLLON2)(void); */
static PyObject *f2py_rout_test.pyf_RollOn2(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.RollOn2",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of RollOn2 *******************************/

/********************************** VertRoll **********************************/
static char doc_f2py_rout_test.pyf_VertRoll[] = "\
VertRoll(x1max,y1max,z1max)\n\nWrapper for ``VertRoll``.\
\n\nParameters\n----------\n"
"x1max : input float\n"
"y1max : input float\n"
"z1max : input float";
/* extern void F_FUNC(VertRoll,VERTROLL)(float*,float*,float*); */
static PyObject *f2py_rout_test.pyf_VertRoll(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float x1max = 0;
  PyObject *x1max_capi = Py_None;
  float y1max = 0;
  PyObject *y1max_capi = Py_None;
  float z1max = 0;
  PyObject *z1max_capi = Py_None;
  static char *capi_kwlist[] = {"x1max","y1max","z1max",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:test.pyf.VertRoll",\
    capi_kwlist,&x1max_capi,&y1max_capi,&z1max_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x1max */
    f2py_success = float_from_pyobj(&x1max,x1max_capi,"test.pyf.VertRoll() 1st argument (x1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable y1max */
    f2py_success = float_from_pyobj(&y1max,y1max_capi,"test.pyf.VertRoll() 2nd argument (y1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable z1max */
    f2py_success = float_from_pyobj(&z1max,z1max_capi,"test.pyf.VertRoll() 3rd argument (z1max) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&x1max,&y1max,&z1max);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of z1max*/
  /* End of cleaning variable z1max */
  } /*if (f2py_success) of y1max*/
  /* End of cleaning variable y1max */
  } /*if (f2py_success) of x1max*/
  /* End of cleaning variable x1max */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of VertRoll ******************************/

/********************************** CalRLoc **********************************/
static char doc_f2py_rout_test.pyf_CalRLoc[] = "\
CalRLoc(x1max,y1max,z1max,x0,y0,z0,rtrack)\n\nWrapper for ``CalRLoc``.\
\n\nParameters\n----------\n"
"x1max : input float\n"
"y1max : input float\n"
"z1max : input float\n"
"x0 : input float\n"
"y0 : input float\n"
"z0 : input float\n"
"rtrack : input float";
/* extern void F_FUNC(CalRLoc,CALRLOC)(float*,float*,float*,float*,float*,float*,float*); */
static PyObject *f2py_rout_test.pyf_CalRLoc(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,float*,float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float x1max = 0;
  PyObject *x1max_capi = Py_None;
  float y1max = 0;
  PyObject *y1max_capi = Py_None;
  float z1max = 0;
  PyObject *z1max_capi = Py_None;
  float x0 = 0;
  PyObject *x0_capi = Py_None;
  float y0 = 0;
  PyObject *y0_capi = Py_None;
  float z0 = 0;
  PyObject *z0_capi = Py_None;
  float rtrack = 0;
  PyObject *rtrack_capi = Py_None;
  static char *capi_kwlist[] = {"x1max","y1max","z1max","x0","y0","z0","rtrack",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOO:test.pyf.CalRLoc",\
    capi_kwlist,&x1max_capi,&y1max_capi,&z1max_capi,&x0_capi,&y0_capi,&z0_capi,&rtrack_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x1max */
    f2py_success = float_from_pyobj(&x1max,x1max_capi,"test.pyf.CalRLoc() 1st argument (x1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable y1max */
    f2py_success = float_from_pyobj(&y1max,y1max_capi,"test.pyf.CalRLoc() 2nd argument (y1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable z1max */
    f2py_success = float_from_pyobj(&z1max,z1max_capi,"test.pyf.CalRLoc() 3rd argument (z1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable x0 */
    f2py_success = float_from_pyobj(&x0,x0_capi,"test.pyf.CalRLoc() 4th argument (x0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable y0 */
    f2py_success = float_from_pyobj(&y0,y0_capi,"test.pyf.CalRLoc() 5th argument (y0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable z0 */
    f2py_success = float_from_pyobj(&z0,z0_capi,"test.pyf.CalRLoc() 6th argument (z0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable rtrack */
    f2py_success = float_from_pyobj(&rtrack,rtrack_capi,"test.pyf.CalRLoc() 7th argument (rtrack) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&x1max,&y1max,&z1max,&x0,&y0,&z0,&rtrack);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of rtrack*/
  /* End of cleaning variable rtrack */
  } /*if (f2py_success) of z0*/
  /* End of cleaning variable z0 */
  } /*if (f2py_success) of y0*/
  /* End of cleaning variable y0 */
  } /*if (f2py_success) of x0*/
  /* End of cleaning variable x0 */
  } /*if (f2py_success) of z1max*/
  /* End of cleaning variable z1max */
  } /*if (f2py_success) of y1max*/
  /* End of cleaning variable y1max */
  } /*if (f2py_success) of x1max*/
  /* End of cleaning variable x1max */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of CalRLoc *******************************/

/********************************** TransFwd **********************************/
static char doc_f2py_rout_test.pyf_TransFwd[] = "\
TransFwd(x1max,y1max,z1max,x0,y0,z0,rtrack)\n\nWrapper for ``TransFwd``.\
\n\nParameters\n----------\n"
"x1max : input float\n"
"y1max : input float\n"
"z1max : input float\n"
"x0 : input float\n"
"y0 : input float\n"
"z0 : input float\n"
"rtrack : input float";
/* extern void F_FUNC(TransFwd,TRANSFWD)(float*,float*,float*,float*,float*,float*,float*); */
static PyObject *f2py_rout_test.pyf_TransFwd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*,float*,float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float x1max = 0;
  PyObject *x1max_capi = Py_None;
  float y1max = 0;
  PyObject *y1max_capi = Py_None;
  float z1max = 0;
  PyObject *z1max_capi = Py_None;
  float x0 = 0;
  PyObject *x0_capi = Py_None;
  float y0 = 0;
  PyObject *y0_capi = Py_None;
  float z0 = 0;
  PyObject *z0_capi = Py_None;
  float rtrack = 0;
  PyObject *rtrack_capi = Py_None;
  static char *capi_kwlist[] = {"x1max","y1max","z1max","x0","y0","z0","rtrack",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOOOOOO:test.pyf.TransFwd",\
    capi_kwlist,&x1max_capi,&y1max_capi,&z1max_capi,&x0_capi,&y0_capi,&z0_capi,&rtrack_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x1max */
    f2py_success = float_from_pyobj(&x1max,x1max_capi,"test.pyf.TransFwd() 1st argument (x1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable y1max */
    f2py_success = float_from_pyobj(&y1max,y1max_capi,"test.pyf.TransFwd() 2nd argument (y1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable z1max */
    f2py_success = float_from_pyobj(&z1max,z1max_capi,"test.pyf.TransFwd() 3rd argument (z1max) can't be converted to float");
  if (f2py_success) {
  /* Processing variable x0 */
    f2py_success = float_from_pyobj(&x0,x0_capi,"test.pyf.TransFwd() 4th argument (x0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable y0 */
    f2py_success = float_from_pyobj(&y0,y0_capi,"test.pyf.TransFwd() 5th argument (y0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable z0 */
    f2py_success = float_from_pyobj(&z0,z0_capi,"test.pyf.TransFwd() 6th argument (z0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable rtrack */
    f2py_success = float_from_pyobj(&rtrack,rtrack_capi,"test.pyf.TransFwd() 7th argument (rtrack) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&x1max,&y1max,&z1max,&x0,&y0,&z0,&rtrack);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of rtrack*/
  /* End of cleaning variable rtrack */
  } /*if (f2py_success) of z0*/
  /* End of cleaning variable z0 */
  } /*if (f2py_success) of y0*/
  /* End of cleaning variable y0 */
  } /*if (f2py_success) of x0*/
  /* End of cleaning variable x0 */
  } /*if (f2py_success) of z1max*/
  /* End of cleaning variable z1max */
  } /*if (f2py_success) of y1max*/
  /* End of cleaning variable y1max */
  } /*if (f2py_success) of x1max*/
  /* End of cleaning variable x1max */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of TransFwd ******************************/

/********************************** TransBwd **********************************/
static char doc_f2py_rout_test.pyf_TransBwd[] = "\
TransBwd(x0,y0,z0)\n\nWrapper for ``TransBwd``.\
\n\nParameters\n----------\n"
"x0 : input float\n"
"y0 : input float\n"
"z0 : input float";
/* extern void F_FUNC(TransBwd,TRANSBWD)(float*,float*,float*); */
static PyObject *f2py_rout_test.pyf_TransBwd(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(float*,float*,float*)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  float x0 = 0;
  PyObject *x0_capi = Py_None;
  float y0 = 0;
  PyObject *y0_capi = Py_None;
  float z0 = 0;
  PyObject *z0_capi = Py_None;
  static char *capi_kwlist[] = {"x0","y0","z0",NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    "OOO:test.pyf.TransBwd",\
    capi_kwlist,&x0_capi,&y0_capi,&z0_capi))
    return NULL;
/*frompyobj*/
  /* Processing variable x0 */
    f2py_success = float_from_pyobj(&x0,x0_capi,"test.pyf.TransBwd() 1st argument (x0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable y0 */
    f2py_success = float_from_pyobj(&y0,y0_capi,"test.pyf.TransBwd() 2nd argument (y0) can't be converted to float");
  if (f2py_success) {
  /* Processing variable z0 */
    f2py_success = float_from_pyobj(&z0,z0_capi,"test.pyf.TransBwd() 3rd argument (z0) can't be converted to float");
  if (f2py_success) {
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)(&x0,&y0,&z0);
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
  } /*if (f2py_success) of z0*/
  /* End of cleaning variable z0 */
  } /*if (f2py_success) of y0*/
  /* End of cleaning variable y0 */
  } /*if (f2py_success) of x0*/
  /* End of cleaning variable x0 */
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of TransBwd ******************************/

/********************************** ChkCond **********************************/
static char doc_f2py_rout_test.pyf_ChkCond[] = "\
ChkCond()\n\nWrapper for ``ChkCond``.\
\n";
/* extern void F_FUNC(ChkCond,CHKCOND)(void); */
static PyObject *f2py_rout_test.pyf_ChkCond(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.ChkCond",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of ChkCond *******************************/

/*********************************** TmpRec ***********************************/
static char doc_f2py_rout_test.pyf_TmpRec[] = "\
TmpRec()\n\nWrapper for ``TmpRec``.\
\n";
/* extern void F_FUNC(TmpRec,TMPREC)(void); */
static PyObject *f2py_rout_test.pyf_TmpRec(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.TmpRec",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/******************************* end of TmpRec *******************************/

/********************************* LocalShift *********************************/
static char doc_f2py_rout_test.pyf_LocalShift[] = "\
LocalShift()\n\nWrapper for ``LocalShift``.\
\n";
/* extern void F_FUNC(LocalShift,LOCALSHIFT)(void); */
static PyObject *f2py_rout_test.pyf_LocalShift(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.LocalShift",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of LocalShift *****************************/

/********************************* ChooseSite *********************************/
static char doc_f2py_rout_test.pyf_ChooseSite[] = "\
ChooseSite()\n\nWrapper for ``ChooseSite``.\
\n";
/* extern void F_FUNC(ChooseSite,CHOOSESITE)(void); */
static PyObject *f2py_rout_test.pyf_ChooseSite(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.ChooseSite",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/***************************** end of ChooseSite *****************************/

/********************************** Relocate **********************************/
static char doc_f2py_rout_test.pyf_Relocate[] = "\
Relocate()\n\nWrapper for ``Relocate``.\
\n";
/* extern void F_FUNC(Relocate,RELOCATE)(void); */
static PyObject *f2py_rout_test.pyf_Relocate(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.Relocate",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of Relocate ******************************/

/********************************** FinalSet **********************************/
static char doc_f2py_rout_test.pyf_FinalSet[] = "\
FinalSet()\n\nWrapper for ``FinalSet``.\
\n";
/* extern void F_FUNC(FinalSet,FINALSET)(void); */
static PyObject *f2py_rout_test.pyf_FinalSet(const PyObject *capi_self,
                           PyObject *capi_args,
                           PyObject *capi_keywds,
                           void (*f2py_func)(void)) {
  PyObject * volatile capi_buildvalue = NULL;
  volatile int f2py_success = 1;
/*decl*/

  static char *capi_kwlist[] = {NULL};

/*routdebugenter*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_clock();
#endif
  if (!PyArg_ParseTupleAndKeywords(capi_args,capi_keywds,\
    ":test.pyf.FinalSet",\
    capi_kwlist))
    return NULL;
/*frompyobj*/
/*end of frompyobj*/
#ifdef F2PY_REPORT_ATEXIT
f2py_start_call_clock();
#endif
/*callfortranroutine*/
        (*f2py_func)();
if (PyErr_Occurred())
  f2py_success = 0;
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_call_clock();
#endif
/*end of callfortranroutine*/
    if (f2py_success) {
/*pyobjfrom*/
/*end of pyobjfrom*/
    CFUNCSMESS("Building return value.\n");
    capi_buildvalue = Py_BuildValue("");
/*closepyobjfrom*/
/*end of closepyobjfrom*/
    } /*if (f2py_success) after callfortranroutine*/
/*cleanupfrompyobj*/
/*end of cleanupfrompyobj*/
  if (capi_buildvalue == NULL) {
/*routdebugfailure*/
  } else {
/*routdebugleave*/
  }
  CFUNCSMESS("Freeing memory.\n");
/*freemem*/
#ifdef F2PY_REPORT_ATEXIT
f2py_stop_clock();
#endif
  return capi_buildvalue;
}
/****************************** end of FinalSet ******************************/
/*eof body*/

/******************* See f2py2e/f90mod_rules.py: buildhooks *******************/
/*need_f90modhooks*/

/************** See f2py2e/rules.py: module_rules['modulebody'] **************/

/******************* See f2py2e/common_rules.py: buildhooks *******************/

static FortranDataDef f2py_dist_def[] = {
  {"alphar",0,{{-1}},NPY_FLOAT},
  {"betar",0,{{-1}},NPY_FLOAT},
  {"cnfint",0,{{-1}},NPY_FLOAT},
  {"rmin",0,{{-1}},NPY_FLOAT},
  {"rmax",0,{{-1}},NPY_FLOAT},
  {"sdnrm",0,{{-1}},NPY_FLOAT},
  {NULL}
};
static void f2py_setup_dist(char *alphar,char *betar,char *cnfint,char *rmin,char *rmax,char *sdnrm) {
  int i_f2py=0;
  f2py_dist_def[i_f2py++].data = alphar;
  f2py_dist_def[i_f2py++].data = betar;
  f2py_dist_def[i_f2py++].data = cnfint;
  f2py_dist_def[i_f2py++].data = rmin;
  f2py_dist_def[i_f2py++].data = rmax;
  f2py_dist_def[i_f2py++].data = sdnrm;
}
extern void F_FUNC(f2pyinitdist,F2PYINITDIST)(void(*)(char*,char*,char*,char*,char*,char*));
static void f2py_init_dist(void) {
  F_FUNC(f2pyinitdist,F2PYINITDIST)(f2py_setup_dist);
}

static FortranDataDef f2py_param_def[] = {
  {"bound",0,{{-1}},NPY_FLOAT},
  {"cmptln",0,{{-1}},NPY_FLOAT},
  {"dtheta",0,{{-1}},NPY_FLOAT},
  {"eps",0,{{-1}},NPY_FLOAT},
  {"height",0,{{-1}},NPY_FLOAT},
  {"nc",0,{{-1}},NPY_INT},
  {"n               npart_kz",0,{{-1}},NPY_INT},
  {"pi",0,{{-1}},NPY_FLOAT},
  {"porosity",0,{{-1}},NPY_FLOAT},
  {"rlmt",0,{{-1}},NPY_FLOAT},
  {"nrndsd",0,{{-1}},NPY_INT},
  {"size_bn",0,{{-1}},NPY_FLOAT},
  {"theta",0,{{-1}},NPY_FLOAT},
  {"tolrnce",0,{{-1}},NPY_FLOAT},
  {"ncz",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_param(char *bound,char *cmptln,char *dtheta,char *eps,char *height,char *nc,char *n               npart_kz,char *pi,char *porosity,char *rlmt,char *nrndsd,char *size_bn,char *theta,char *tolrnce,char *ncz) {
  int i_f2py=0;
  f2py_param_def[i_f2py++].data = bound;
  f2py_param_def[i_f2py++].data = cmptln;
  f2py_param_def[i_f2py++].data = dtheta;
  f2py_param_def[i_f2py++].data = eps;
  f2py_param_def[i_f2py++].data = height;
  f2py_param_def[i_f2py++].data = nc;
  f2py_param_def[i_f2py++].data = n               npart_kz;
  f2py_param_def[i_f2py++].data = pi;
  f2py_param_def[i_f2py++].data = porosity;
  f2py_param_def[i_f2py++].data = rlmt;
  f2py_param_def[i_f2py++].data = nrndsd;
  f2py_param_def[i_f2py++].data = size_bn;
  f2py_param_def[i_f2py++].data = theta;
  f2py_param_def[i_f2py++].data = tolrnce;
  f2py_param_def[i_f2py++].data = ncz;
}
extern void F_FUNC(f2pyinitparam,F2PYINITPARAM)(void(*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_param(void) {
  F_FUNC(f2pyinitparam,F2PYINITPARAM)(f2py_setup_param);
}

static FortranDataDef f2py_local_def[] = {
  {"intensity",0,{{-1}},NPY_INT},
  {"lshift",0,{{-1}},NPY_INT},
  {"move",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_local(char *intensity,char *lshift,char *move) {
  int i_f2py=0;
  f2py_local_def[i_f2py++].data = intensity;
  f2py_local_def[i_f2py++].data = lshift;
  f2py_local_def[i_f2py++].data = move;
}
extern void F_FUNC(f2pyinitlocal,F2PYINITLOCAL)(void(*)(char*,char*,char*));
static void f2py_init_local(void) {
  F_FUNC(f2pyinitlocal,F2PYINITLOCAL)(f2py_setup_local);
}

static FortranDataDef f2py_corr_def[] = {
  {"ncor",0,{{-1}},NPY_INT},
  {"gridln",0,{{-1}},NPY_FLOAT},
  {"Ngrid",0,{{-1}},NPY_INT},
  {"Nzgrid",0,{{-1}},NPY_INT},
  {"mr",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_corr(char *ncor,char *gridln,char *Ngrid,char *Nzgrid,char *mr) {
  int i_f2py=0;
  f2py_corr_def[i_f2py++].data = ncor;
  f2py_corr_def[i_f2py++].data = gridln;
  f2py_corr_def[i_f2py++].data = Ngrid;
  f2py_corr_def[i_f2py++].data = Nzgrid;
  f2py_corr_def[i_f2py++].data = mr;
}
extern void F_FUNC(f2pyinitcorr,F2PYINITCORR)(void(*)(char*,char*,char*,char*,char*));
static void f2py_init_corr(void) {
  F_FUNC(f2pyinitcorr,F2PYINITCORR)(f2py_setup_corr);
}

static FortranDataDef f2py_index_def[] = {
  {"mcount",0,{{-1}},NPY_INT},
  {"movlpcond",0,{{-1}},NPY_INT},
  {"mpBC",0,{{-1}},NPY_INT},
  {"mroll",0,{{-1}},NPY_INT},
  {"nrec",0,{{-1}},NPY_INT},
  {"ntshift",0,{{-1}},NPY_INT},
  {"niterate",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_index(char *mcount,char *movlpcond,char *mpBC,char *mroll,char *nrec,char *ntshift,char *niterate) {
  int i_f2py=0;
  f2py_index_def[i_f2py++].data = mcount;
  f2py_index_def[i_f2py++].data = movlpcond;
  f2py_index_def[i_f2py++].data = mpBC;
  f2py_index_def[i_f2py++].data = mroll;
  f2py_index_def[i_f2py++].data = nrec;
  f2py_index_def[i_f2py++].data = ntshift;
  f2py_index_def[i_f2py++].data = niterate;
}
extern void F_FUNC(f2pyinitindex,F2PYINITINDEX)(void(*)(char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_index(void) {
  F_FUNC(f2pyinitindex,F2PYINITINDEX)(f2py_setup_index);
}

static FortranDataDef f2py_origdim_def[] = {
  {"r",1,{{100000}},NPY_FLOAT},
  {"rc",3,{{200,200,200}},NPY_FLOAT},
  {"x",1,{{100000}},NPY_FLOAT},
  {"xc",3,{{200,200,200}},NPY_FLOAT},
  {"y",1,{{100000}},NPY_FLOAT},
  {"yc",3,{{200,200,200}},NPY_FLOAT},
  {"z",1,{{100000}},NPY_FLOAT},
  {"zc",3,{{200,200,200}},NPY_FLOAT},
  {"icnt",2,{{200,200}},NPY_INT},
  {NULL}
};
static void f2py_setup_origdim(char *r,char *rc,char *x,char *xc,char *y,char *yc,char *z,char *zc,char *icnt) {
  int i_f2py=0;
  f2py_origdim_def[i_f2py++].data = r;
  f2py_origdim_def[i_f2py++].data = rc;
  f2py_origdim_def[i_f2py++].data = x;
  f2py_origdim_def[i_f2py++].data = xc;
  f2py_origdim_def[i_f2py++].data = y;
  f2py_origdim_def[i_f2py++].data = yc;
  f2py_origdim_def[i_f2py++].data = z;
  f2py_origdim_def[i_f2py++].data = zc;
  f2py_origdim_def[i_f2py++].data = icnt;
}
extern void F_FUNC(f2pyinitorigdim,F2PYINITORIGDIM)(void(*)(char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_origdim(void) {
  F_FUNC(f2pyinitorigdim,F2PYINITORIGDIM)(f2py_setup_origdim);
}

static FortranDataDef f2py_MCHCOM_def[] = {
  {"BASE",0,{{-1}},NPY_FLOAT},
  {"DNOT",1,{{3}},NPY_FLOAT},
  {"FINITY",0,{{-1}},NPY_FLOAT},
  {NULL}
};
static void f2py_setup_MCHCOM(char *BASE,char *DNOT,char *FINITY) {
  int i_f2py=0;
  f2py_MCHCOM_def[i_f2py++].data = BASE;
  f2py_MCHCOM_def[i_f2py++].data = DNOT;
  f2py_MCHCOM_def[i_f2py++].data = FINITY;
}
extern void F_FUNC(f2pyinitmchcom,F2PYINITMCHCOM)(void(*)(char*,char*,char*));
static void f2py_init_MCHCOM(void) {
  F_FUNC(f2pyinitmchcom,F2PYINITMCHCOM)(f2py_setup_MCHCOM);
}

static FortranDataDef f2py_data_def[] = {
  {"icst2",0,{{-1}},NPY_INT},
  {"icst3",0,{{-1}},NPY_INT},
  {"icst4",0,{{-1}},NPY_INT},
  {"i1x",0,{{-1}},NPY_INT},
  {"i1x1",0,{{-1}},NPY_INT},
  {"i1x2",0,{{-1}},NPY_INT},
  {"i1x3              jy",0,{{-1}},NPY_INT},
  {"jy1",0,{{-1}},NPY_INT},
  {"jy2",0,{{-1}},NPY_INT},
  {"jy3",0,{{-1}},NPY_INT},
  {"jy4",0,{{-1}},NPY_INT},
  {"kz",0,{{-1}},NPY_INT},
  {"kz1",0,{{-1}},NPY_INT},
  {"kz2",0,{{-1}},NPY_INT},
  {"kz3",0,{{-1}},NPY_INT},
  {"kz4",0,{{-1}},NPY_INT},
  {"r1",0,{{-1}},NPY_FLOAT},
  {"r2",0,{{-1}},NPY_FLOAT},
  {"r3",0,{{-1}},NPY_FLOAT},
  {"r4",0,{{-1}},NPY_FLOAT},
  {"x1",0,{{-1}},NPY_FLOAT},
  {"x2",0,{{-1}},NPY_FLOAT},
  {"x3",0,{{-1}},NPY_FLOAT},
  {"x4",0,{{-1}},NPY_FLOAT},
  {"y1",0,{{-1}},NPY_FLOAT},
  {"y2",0,{{-1}},NPY_FLOAT},
  {"y3",0,{{-1}},NPY_FLOAT},
  {"y4",0,{{-1}},NPY_FLOAT},
  {"z1",0,{{-1}},NPY_FLOAT},
  {"z2",0,{{-1}},NPY_FLOAT},
  {"z3",0,{{-1}},NPY_FLOAT},
  {"z4",0,{{-1}},NPY_FLOAT},
  {NULL}
};
static void f2py_setup_data(char *icst2,char *icst3,char *icst4,char *i1x,char *i1x1,char *i1x2,char *i1x3              jy,char *jy1,char *jy2,char *jy3,char *jy4,char *kz,char *kz1,char *kz2,char *kz3,char *kz4,char *r1,char *r2,char *r3,char *r4,char *x1,char *x2,char *x3,char *x4,char *y1,char *y2,char *y3,char *y4,char *z1,char *z2,char *z3,char *z4) {
  int i_f2py=0;
  f2py_data_def[i_f2py++].data = icst2;
  f2py_data_def[i_f2py++].data = icst3;
  f2py_data_def[i_f2py++].data = icst4;
  f2py_data_def[i_f2py++].data = i1x;
  f2py_data_def[i_f2py++].data = i1x1;
  f2py_data_def[i_f2py++].data = i1x2;
  f2py_data_def[i_f2py++].data = i1x3              jy;
  f2py_data_def[i_f2py++].data = jy1;
  f2py_data_def[i_f2py++].data = jy2;
  f2py_data_def[i_f2py++].data = jy3;
  f2py_data_def[i_f2py++].data = jy4;
  f2py_data_def[i_f2py++].data = kz;
  f2py_data_def[i_f2py++].data = kz1;
  f2py_data_def[i_f2py++].data = kz2;
  f2py_data_def[i_f2py++].data = kz3;
  f2py_data_def[i_f2py++].data = kz4;
  f2py_data_def[i_f2py++].data = r1;
  f2py_data_def[i_f2py++].data = r2;
  f2py_data_def[i_f2py++].data = r3;
  f2py_data_def[i_f2py++].data = r4;
  f2py_data_def[i_f2py++].data = x1;
  f2py_data_def[i_f2py++].data = x2;
  f2py_data_def[i_f2py++].data = x3;
  f2py_data_def[i_f2py++].data = x4;
  f2py_data_def[i_f2py++].data = y1;
  f2py_data_def[i_f2py++].data = y2;
  f2py_data_def[i_f2py++].data = y3;
  f2py_data_def[i_f2py++].data = y4;
  f2py_data_def[i_f2py++].data = z1;
  f2py_data_def[i_f2py++].data = z2;
  f2py_data_def[i_f2py++].data = z3;
  f2py_data_def[i_f2py++].data = z4;
}
extern void F_FUNC(f2pyinitdata,F2PYINITDATA)(void(*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_data(void) {
  F_FUNC(f2pyinitdata,F2PYINITDATA)(f2py_setup_data);
}

static FortranDataDef f2py_sortdim_def[] = {
  {"rcst",4,{{200,200,200,200}},NPY_FLOAT},
  {"xcst",4,{{200,200,200,200}},NPY_FLOAT},
  {"ycst",4,{{200,200,200,200}},NPY_FLOAT},
  {"zcst",4,{{200,200,200,200}},NPY_FLOAT},
  {"icntst",3,{{200,200,200}},NPY_INT},
  {NULL}
};
static void f2py_setup_sortdim(char *rcst,char *xcst,char *ycst,char *zcst,char *icntst) {
  int i_f2py=0;
  f2py_sortdim_def[i_f2py++].data = rcst;
  f2py_sortdim_def[i_f2py++].data = xcst;
  f2py_sortdim_def[i_f2py++].data = ycst;
  f2py_sortdim_def[i_f2py++].data = zcst;
  f2py_sortdim_def[i_f2py++].data = icntst;
}
extern void F_FUNC(f2pyinitsortdim,F2PYINITSORTDIM)(void(*)(char*,char*,char*,char*,char*));
static void f2py_init_sortdim(void) {
  F_FUNC(f2pyinitsortdim,F2PYINITSORTDIM)(f2py_setup_sortdim);
}

static FortranDataDef f2py_tmp_def[] = {
  {"mrolltmp",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_tmp(char *mrolltmp) {
  int i_f2py=0;
  f2py_tmp_def[i_f2py++].data = mrolltmp;
}
extern void F_FUNC(f2pyinittmp,F2PYINITTMP)(void(*)(char*));
static void f2py_init_tmp(void) {
  F_FUNC(f2pyinittmp,F2PYINITTMP)(f2py_setup_tmp);
}

static FortranDataDef f2py_flag_def[] = {
  {"mark",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_flag(char *mark) {
  int i_f2py=0;
  f2py_flag_def[i_f2py++].data = mark;
}
extern void F_FUNC(f2pyinitflag,F2PYINITFLAG)(void(*)(char*));
static void f2py_init_flag(void) {
  F_FUNC(f2pyinitflag,F2PYINITFLAG)(f2py_setup_flag);
}

static FortranDataDef f2py_sign_def[] = {
  {"lsign",0,{{-1}},NPY_INT},
  {NULL}
};
static void f2py_setup_sign(char *lsign) {
  int i_f2py=0;
  f2py_sign_def[i_f2py++].data = lsign;
}
extern void F_FUNC(f2pyinitsign,F2PYINITSIGN)(void(*)(char*));
static void f2py_init_sign(void) {
  F_FUNC(f2pyinitsign,F2PYINITSIGN)(f2py_setup_sign);
}

static FortranDataDef f2py_data1_def[] = {
  {"x11",0,{{-1}},NPY_FLOAT},
  {"x12",0,{{-1}},NPY_FLOAT},
  {"x13",0,{{-1}},NPY_FLOAT},
  {"x11max",0,{{-1}},NPY_FLOAT},
  {"y11",0,{{-1}},NPY_FLOAT},
  {"y12",0,{{-1}},NPY_FLOAT},
  {"y13",0,{{-1}},NPY_FLOAT},
  {"y11               z11",0,{{-1}},NPY_FLOAT},
  {"z12",0,{{-1}},NPY_FLOAT},
  {"z11max",0,{{-1}},NPY_FLOAT},
  {"rxy",0,{{-1}},NPY_FLOAT},
  {"sineA",0,{{-1}},NPY_FLOAT},
  {"cosineA",0,{{-1}},NPY_FLOAT},
  {"sineB",0,{{-1}},NPY_FLOAT},
  {"cosineB",0,{{-1}},NPY_FLOAT},
  {NULL}
};
static void f2py_setup_data1(char *x11,char *x12,char *x13,char *x11max,char *y11,char *y12,char *y13,char *y11               z11,char *z12,char *z11max,char *rxy,char *sineA,char *cosineA,char *sineB,char *cosineB) {
  int i_f2py=0;
  f2py_data1_def[i_f2py++].data = x11;
  f2py_data1_def[i_f2py++].data = x12;
  f2py_data1_def[i_f2py++].data = x13;
  f2py_data1_def[i_f2py++].data = x11max;
  f2py_data1_def[i_f2py++].data = y11;
  f2py_data1_def[i_f2py++].data = y12;
  f2py_data1_def[i_f2py++].data = y13;
  f2py_data1_def[i_f2py++].data = y11               z11;
  f2py_data1_def[i_f2py++].data = z12;
  f2py_data1_def[i_f2py++].data = z11max;
  f2py_data1_def[i_f2py++].data = rxy;
  f2py_data1_def[i_f2py++].data = sineA;
  f2py_data1_def[i_f2py++].data = cosineA;
  f2py_data1_def[i_f2py++].data = sineB;
  f2py_data1_def[i_f2py++].data = cosineB;
}
extern void F_FUNC(f2pyinitdata1,F2PYINITDATA1)(void(*)(char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_data1(void) {
  F_FUNC(f2pyinitdata1,F2PYINITDATA1)(f2py_setup_data1);
}

static FortranDataDef f2py_shift_def[] = {
  {"xshift",1,{{30}},NPY_FLOAT},
  {"yshift",1,{{30}},NPY_FLOAT},
  {"zshift",1,{{30}},NPY_FLOAT},
  {"i1xshift",1,{{30}},NPY_INT},
  {"jyshift",1,{{30}},NPY_INT},
  {"kzshift",1,{{30}},NPY_INT},
  {"indx",1,{{30}},NPY_INT},
  {NULL}
};
static void f2py_setup_shift(char *xshift,char *yshift,char *zshift,char *i1xshift,char *jyshift,char *kzshift,char *indx) {
  int i_f2py=0;
  f2py_shift_def[i_f2py++].data = xshift;
  f2py_shift_def[i_f2py++].data = yshift;
  f2py_shift_def[i_f2py++].data = zshift;
  f2py_shift_def[i_f2py++].data = i1xshift;
  f2py_shift_def[i_f2py++].data = jyshift;
  f2py_shift_def[i_f2py++].data = kzshift;
  f2py_shift_def[i_f2py++].data = indx;
}
extern void F_FUNC(f2pyinitshift,F2PYINITSHIFT)(void(*)(char*,char*,char*,char*,char*,char*,char*));
static void f2py_init_shift(void) {
  F_FUNC(f2pyinitshift,F2PYINITSHIFT)(f2py_setup_shift);
}

/*need_commonhooks*/

/**************************** See f2py2e/rules.py ****************************/

static FortranDataDef f2py_routine_defs[] = {
  {"ReadParam",-1,{{-1}},0,(char *)F_FUNC(ReadParam,READPARAM),(f2py_init_func)f2py_rout_test.pyf_ReadParam,doc_f2py_rout_test.pyf_ReadParam},
  {"RndmPack",-1,{{-1}},0,(char *)F_FUNC(RndmPack,RNDMPACK),(f2py_init_func)f2py_rout_test.pyf_RndmPack,doc_f2py_rout_test.pyf_RndmPack},
  {"GnrtRdii",-1,{{-1}},0,(char *)F_FUNC(GnrtRdii,GNRTRDII),(f2py_init_func)f2py_rout_test.pyf_GnrtRdii,doc_f2py_rout_test.pyf_GnrtRdii},
  {"RNorm",-1,{{-1}},0,(char *)F_FUNC(RNorm,RNORM),(f2py_init_func)f2py_rout_test.pyf_RNorm,doc_f2py_rout_test.pyf_RNorm},
  {"RInvNorm",-1,{{-1}},0,(char *)F_WRAPPEDFUNC(rinvnorm,RINVNORM),(f2py_init_func)f2py_rout_test.pyf_RInvNorm,doc_f2py_rout_test.pyf_RInvNorm},
  {"GnrtSite",-1,{{-1}},0,(char *)F_FUNC(GnrtSite,GNRTSITE),(f2py_init_func)f2py_rout_test.pyf_GnrtSite,doc_f2py_rout_test.pyf_GnrtSite},
  {"GnrtPack",-1,{{-1}},0,(char *)F_FUNC(GnrtPack,GNRTPACK),(f2py_init_func)f2py_rout_test.pyf_GnrtPack,doc_f2py_rout_test.pyf_GnrtPack},
  {"Output",-1,{{-1}},0,(char *)F_FUNC(Output,OUTPUT),(f2py_init_func)f2py_rout_test.pyf_Output,doc_f2py_rout_test.pyf_Output},
  {"AlloctCmpt",-1,{{-1}},0,(char *)F_FUNC(AlloctCmpt,ALLOCTCMPT),(f2py_init_func)f2py_rout_test.pyf_AlloctCmpt,doc_f2py_rout_test.pyf_AlloctCmpt},
  {"InitialCnt",-1,{{-1}},0,(char *)F_FUNC(InitialCnt,INITIALCNT),(f2py_init_func)f2py_rout_test.pyf_InitialCnt,doc_f2py_rout_test.pyf_InitialCnt},
  {"Allocating",-1,{{-1}},0,(char *)F_FUNC(Allocating,ALLOCATING),(f2py_init_func)f2py_rout_test.pyf_Allocating,doc_f2py_rout_test.pyf_Allocating},
  {"Sort",-1,{{-1}},0,(char *)F_FUNC(Sort,SORT),(f2py_init_func)f2py_rout_test.pyf_Sort,doc_f2py_rout_test.pyf_Sort},
  {"InitialSort",-1,{{-1}},0,(char *)F_FUNC(InitialSort,INITIALSORT),(f2py_init_func)f2py_rout_test.pyf_InitialSort,doc_f2py_rout_test.pyf_InitialSort},
  {"FindZmin",-1,{{-1}},0,(char *)F_FUNC(FindZmin,FINDZMIN),(f2py_init_func)f2py_rout_test.pyf_FindZmin,doc_f2py_rout_test.pyf_FindZmin},
  {"Reorder",-1,{{-1}},0,(char *)F_FUNC(Reorder,REORDER),(f2py_init_func)f2py_rout_test.pyf_Reorder,doc_f2py_rout_test.pyf_Reorder},
  {"Sorting",-1,{{-1}},0,(char *)F_FUNC(Sorting,SORTING),(f2py_init_func)f2py_rout_test.pyf_Sorting,doc_f2py_rout_test.pyf_Sorting},
  {"FindXYZ",-1,{{-1}},0,(char *)F_FUNC(FindXYZ,FINDXYZ),(f2py_init_func)f2py_rout_test.pyf_FindXYZ,doc_f2py_rout_test.pyf_FindXYZ},
  {"Shift1",-1,{{-1}},0,(char *)F_FUNC(Shift1,SHIFT1),(f2py_init_func)f2py_rout_test.pyf_Shift1,doc_f2py_rout_test.pyf_Shift1},
  {"Shift2",-1,{{-1}},0,(char *)F_FUNC(Shift2,SHIFT2),(f2py_init_func)f2py_rout_test.pyf_Shift2,doc_f2py_rout_test.pyf_Shift2},
  {"Shift3",-1,{{-1}},0,(char *)F_FUNC(Shift3,SHIFT3),(f2py_init_func)f2py_rout_test.pyf_Shift3,doc_f2py_rout_test.pyf_Shift3},
  {"Shift4",-1,{{-1}},0,(char *)F_FUNC(Shift4,SHIFT4),(f2py_init_func)f2py_rout_test.pyf_Shift4,doc_f2py_rout_test.pyf_Shift4},
  {"ChkOvlp",-1,{{-1}},0,(char *)F_FUNC(ChkOvlp,CHKOVLP),(f2py_init_func)f2py_rout_test.pyf_ChkOvlp,doc_f2py_rout_test.pyf_ChkOvlp},
  {"FindZmax",-1,{{-1}},0,(char *)F_FUNC(FindZmax,FINDZMAX),(f2py_init_func)f2py_rout_test.pyf_FindZmax,doc_f2py_rout_test.pyf_FindZmax},
  {"Roll1Loc",-1,{{-1}},0,(char *)F_FUNC(Roll1Loc,ROLL1LOC),(f2py_init_func)f2py_rout_test.pyf_Roll1Loc,doc_f2py_rout_test.pyf_Roll1Loc},
  {"CalR1Loc",-1,{{-1}},0,(char *)F_FUNC(CalR1Loc,CALR1LOC),(f2py_init_func)f2py_rout_test.pyf_CalR1Loc,doc_f2py_rout_test.pyf_CalR1Loc},
  {"Roll2Loc",-1,{{-1}},0,(char *)F_FUNC(Roll2Loc,ROLL2LOC),(f2py_init_func)f2py_rout_test.pyf_Roll2Loc,doc_f2py_rout_test.pyf_Roll2Loc},
  {"CalR2Loc",-1,{{-1}},0,(char *)F_FUNC(CalR2Loc,CALR2LOC),(f2py_init_func)f2py_rout_test.pyf_CalR2Loc,doc_f2py_rout_test.pyf_CalR2Loc},
  {"Register",-1,{{-1}},0,(char *)F_FUNC(Register,REGISTER),(f2py_init_func)f2py_rout_test.pyf_Register,doc_f2py_rout_test.pyf_Register},
  {"ShiftDown",-1,{{-1}},0,(char *)F_FUNC(ShiftDown,SHIFTDOWN),(f2py_init_func)f2py_rout_test.pyf_ShiftDown,doc_f2py_rout_test.pyf_ShiftDown},
  {"FindLocBC",-1,{{-1}},0,(char *)F_FUNC(FindLocBC,FINDLOCBC),(f2py_init_func)f2py_rout_test.pyf_FindLocBC,doc_f2py_rout_test.pyf_FindLocBC},
  {"RollItBC",-1,{{-1}},0,(char *)F_FUNC(RollItBC,ROLLITBC),(f2py_init_func)f2py_rout_test.pyf_RollItBC,doc_f2py_rout_test.pyf_RollItBC},
  {"ChkBCmpt",-1,{{-1}},0,(char *)F_FUNC(ChkBCmpt,CHKBCMPT),(f2py_init_func)f2py_rout_test.pyf_ChkBCmpt,doc_f2py_rout_test.pyf_ChkBCmpt},
  {"FindXYZBC",-1,{{-1}},0,(char *)F_FUNC(FindXYZBC,FINDXYZBC),(f2py_init_func)f2py_rout_test.pyf_FindXYZBC,doc_f2py_rout_test.pyf_FindXYZBC},
  {"BCRoll1",-1,{{-1}},0,(char *)F_FUNC(BCRoll1,BCROLL1),(f2py_init_func)f2py_rout_test.pyf_BCRoll1,doc_f2py_rout_test.pyf_BCRoll1},
  {"BCRoll2",-1,{{-1}},0,(char *)F_FUNC(BCRoll2,BCROLL2),(f2py_init_func)f2py_rout_test.pyf_BCRoll2,doc_f2py_rout_test.pyf_BCRoll2},
  {"BCRoll3",-1,{{-1}},0,(char *)F_FUNC(BCRoll3,BCROLL3),(f2py_init_func)f2py_rout_test.pyf_BCRoll3,doc_f2py_rout_test.pyf_BCRoll3},
  {"BCRoll4",-1,{{-1}},0,(char *)F_FUNC(BCRoll4,BCROLL4),(f2py_init_func)f2py_rout_test.pyf_BCRoll4,doc_f2py_rout_test.pyf_BCRoll4},
  {"ChkBCOvlp",-1,{{-1}},0,(char *)F_FUNC(ChkBCOvlp,CHKBCOVLP),(f2py_init_func)f2py_rout_test.pyf_ChkBCOvlp,doc_f2py_rout_test.pyf_ChkBCOvlp},
  {"CalRLocBC",-1,{{-1}},0,(char *)F_FUNC(CalRLocBC,CALRLOCBC),(f2py_init_func)f2py_rout_test.pyf_CalRLocBC,doc_f2py_rout_test.pyf_CalRLocBC},
  {"RelocateBC",-1,{{-1}},0,(char *)F_FUNC(RelocateBC,RELOCATEBC),(f2py_init_func)f2py_rout_test.pyf_RelocateBC,doc_f2py_rout_test.pyf_RelocateBC},
  {"FindLoc",-1,{{-1}},0,(char *)F_FUNC(FindLoc,FINDLOC),(f2py_init_func)f2py_rout_test.pyf_FindLoc,doc_f2py_rout_test.pyf_FindLoc},
  {"RollOn1",-1,{{-1}},0,(char *)F_FUNC(RollOn1,ROLLON1),(f2py_init_func)f2py_rout_test.pyf_RollOn1,doc_f2py_rout_test.pyf_RollOn1},
  {"ChkCmpt",-1,{{-1}},0,(char *)F_FUNC(ChkCmpt,CHKCMPT),(f2py_init_func)f2py_rout_test.pyf_ChkCmpt,doc_f2py_rout_test.pyf_ChkCmpt},
  {"SettleRlmt",-1,{{-1}},0,(char *)F_FUNC(SettleRlmt,SETTLERLMT),(f2py_init_func)f2py_rout_test.pyf_SettleRlmt,doc_f2py_rout_test.pyf_SettleRlmt},
  {"CalRlmtLoc",-1,{{-1}},0,(char *)F_FUNC(CalRlmtLoc,CALRLMTLOC),(f2py_init_func)f2py_rout_test.pyf_CalRlmtLoc,doc_f2py_rout_test.pyf_CalRlmtLoc},
  {"RollOn2",-1,{{-1}},0,(char *)F_FUNC(RollOn2,ROLLON2),(f2py_init_func)f2py_rout_test.pyf_RollOn2,doc_f2py_rout_test.pyf_RollOn2},
  {"VertRoll",-1,{{-1}},0,(char *)F_FUNC(VertRoll,VERTROLL),(f2py_init_func)f2py_rout_test.pyf_VertRoll,doc_f2py_rout_test.pyf_VertRoll},
  {"CalRLoc",-1,{{-1}},0,(char *)F_FUNC(CalRLoc,CALRLOC),(f2py_init_func)f2py_rout_test.pyf_CalRLoc,doc_f2py_rout_test.pyf_CalRLoc},
  {"TransFwd",-1,{{-1}},0,(char *)F_FUNC(TransFwd,TRANSFWD),(f2py_init_func)f2py_rout_test.pyf_TransFwd,doc_f2py_rout_test.pyf_TransFwd},
  {"TransBwd",-1,{{-1}},0,(char *)F_FUNC(TransBwd,TRANSBWD),(f2py_init_func)f2py_rout_test.pyf_TransBwd,doc_f2py_rout_test.pyf_TransBwd},
  {"ChkCond",-1,{{-1}},0,(char *)F_FUNC(ChkCond,CHKCOND),(f2py_init_func)f2py_rout_test.pyf_ChkCond,doc_f2py_rout_test.pyf_ChkCond},
  {"TmpRec",-1,{{-1}},0,(char *)F_FUNC(TmpRec,TMPREC),(f2py_init_func)f2py_rout_test.pyf_TmpRec,doc_f2py_rout_test.pyf_TmpRec},
  {"LocalShift",-1,{{-1}},0,(char *)F_FUNC(LocalShift,LOCALSHIFT),(f2py_init_func)f2py_rout_test.pyf_LocalShift,doc_f2py_rout_test.pyf_LocalShift},
  {"ChooseSite",-1,{{-1}},0,(char *)F_FUNC(ChooseSite,CHOOSESITE),(f2py_init_func)f2py_rout_test.pyf_ChooseSite,doc_f2py_rout_test.pyf_ChooseSite},
  {"Relocate",-1,{{-1}},0,(char *)F_FUNC(Relocate,RELOCATE),(f2py_init_func)f2py_rout_test.pyf_Relocate,doc_f2py_rout_test.pyf_Relocate},
  {"FinalSet",-1,{{-1}},0,(char *)F_FUNC(FinalSet,FINALSET),(f2py_init_func)f2py_rout_test.pyf_FinalSet,doc_f2py_rout_test.pyf_FinalSet},

/*eof routine_defs*/
  {NULL}
};

static PyMethodDef f2py_module_methods[] = {

  {NULL,NULL}
};

#if PY_VERSION_HEX >= 0x03000000
static struct PyModuleDef moduledef = {
  PyModuleDef_HEAD_INIT,
  "test.pyf",
  NULL,
  -1,
  f2py_module_methods,
  NULL,
  NULL,
  NULL,
  NULL
};
#endif

#if PY_VERSION_HEX >= 0x03000000
#define RETVAL m
PyMODINIT_FUNC PyInit_test.pyf(void) {
#else
#define RETVAL
PyMODINIT_FUNC inittest.pyf(void) {
#endif
  int i;
  PyObject *m,*d, *s;
#if PY_VERSION_HEX >= 0x03000000
  m = test.pyf_module = PyModule_Create(&moduledef);
#else
  m = test.pyf_module = Py_InitModule("test.pyf", f2py_module_methods);
#endif
  Py_TYPE(&PyFortran_Type) = &PyType_Type;
  import_array();
  if (PyErr_Occurred())
    {PyErr_SetString(PyExc_ImportError, "can't initialize module test.pyf (failed to import numpy)"); return RETVAL;}
  d = PyModule_GetDict(m);
  s = PyString_FromString("$Revision: $");
  PyDict_SetItemString(d, "__version__", s);
#if PY_VERSION_HEX >= 0x03000000
  s = PyUnicode_FromString(
#else
  s = PyString_FromString(
#endif
    "This module 'test.pyf' is auto-generated with f2py (version:2).\nFunctions:\n"
"  ReadParam()\n"
"  RndmPack()\n"
"  GnrtRdii()\n"
"  RNorm(Mu,Sigma,Sample,Seed)\n"
"  RInvNorm = RInvNorm(P)\n"
"  GnrtSite()\n"
"  GnrtPack()\n"
"  Output()\n"
"  AlloctCmpt()\n"
"  InitialCnt()\n"
"  Allocating(i,mz)\n"
"  Sort()\n"
"  InitialSort(lz)\n"
"  FindZmin(ic1,ncpart1)\n"
"  Reorder(ic1,ncpart1)\n"
"  Sorting(lz)\n"
"  FindXYZ()\n"
"  Shift1(i1xx,jyy,kzz,mflag)\n"
"  Shift2(i1xx,jyy,kzz,mflag)\n"
"  Shift3(i1xx,jyy,kzz,mflag)\n"
"  Shift4(i1xx,jyy,kzz,mflag)\n"
"  ChkOvlp(mflag)\n"
"  FindZmax(mflag)\n"
"  Roll1Loc()\n"
"  CalR1Loc(icst)\n"
"  Roll2Loc()\n"
"  CalR2Loc(icst)\n"
"  Register()\n"
"  ShiftDown()\n"
"  FindLocBC(lz)\n"
"  RollItBC()\n"
"  ChkBCmpt(p1,lp1)\n"
"  FindXYZBC(p1,lp1)\n"
"  BCRoll1(p1,lp1,lpp,kzp)\n"
"  BCRoll2(p1,lp1,lpp,kzp)\n"
"  BCRoll3(p1,lp1,lpp,kzp)\n"
"  BCRoll4(p1,lp1,lpp,kzp)\n"
"  ChkBCOvlp(p1,lp1,lp)\n"
"  CalRLocBC(icst)\n"
"  RelocateBC()\n"
"  FindLoc(lz)\n"
"  RollOn1()\n"
"  ChkCmpt()\n"
"  SettleRlmt()\n"
"  CalRlmtLoc(alpha,alpha2,alpha3)\n"
"  RollOn2()\n"
"  VertRoll(x1max,y1max,z1max)\n"
"  CalRLoc(x1max,y1max,z1max,x0,y0,z0,rtrack)\n"
"  TransFwd(x1max,y1max,z1max,x0,y0,z0,rtrack)\n"
"  TransBwd(x0,y0,z0)\n"
"  ChkCond()\n"
"  TmpRec()\n"
"  LocalShift()\n"
"  ChooseSite()\n"
"  Relocate()\n"
"  FinalSet()\n"
"COMMON blocks:\n""  /dist/ alphar,betar,cnfint,rmin,rmax,sdnrm\n""  /param/ bound,cmptln,dtheta,eps,height,nc,n               npart_kz,pi,porosity,rlmt,nrndsd,size_bn,theta,tolrnce,ncz\n""  /local/ intensity,lshift,move\n""  /corr/ ncor,gridln,Ngrid,Nzgrid,mr\n""  /index/ mcount,movlpcond,mpBC,mroll,nrec,ntshift,niterate\n""  /origdim/ r(100000),rc(200,200,200),x(100000),xc(200,200,200),y(100000),yc(200,200,200),z(100000),zc(200,200,200),icnt(200,200)\n""  /MCHCOM/ BASE,DNOT(3),FINITY\n""  /data/ icst2,icst3,icst4,i1x,i1x1,i1x2,i1x3              jy,jy1,jy2,jy3,jy4,kz,kz1,kz2,kz3,kz4,r1,r2,r3,r4,x1,x2,x3,x4,y1,y2,y3,y4,z1,z2,z3,z4\n""  /sortdim/ rcst(200,200,200,200),xcst(200,200,200,200),ycst(200,200,200,200),zcst(200,200,200,200),icntst(200,200,200)\n""  /tmp/ mrolltmp\n""  /flag/ mark\n""  /sign/ lsign\n""  /data1/ x11,x12,x13,x11max,y11,y12,y13,y11               z11,z12,z11max,rxy,sineA,cosineA,sineB,cosineB\n""  /shift/ xshift(30),yshift(30),zshift(30),i1xshift(30),jyshift(30),kzshift(30),indx(30)\n"".");
  PyDict_SetItemString(d, "__doc__", s);
  test.pyf_error = PyErr_NewException ("test.pyf.error", NULL, NULL);
  Py_DECREF(s);
  for(i=0;f2py_routine_defs[i].name!=NULL;i++)
    PyDict_SetItemString(d, f2py_routine_defs[i].name,PyFortranObject_NewAsAttr(&f2py_routine_defs[i]));





    {
      extern float F_FUNC(rinvnorm,RINVNORM)(void);
      PyObject* o = PyDict_GetItemString(d,"RInvNorm");
      PyObject_SetAttrString(o,"_cpointer", F2PyCapsule_FromVoidPtr((void*)F_FUNC(rinvnorm,RINVNORM),NULL));
#if PY_VERSION_HEX >= 0x03000000
      PyObject_SetAttrString(o,"__name__", PyUnicode_FromString("RInvNorm"));
#else
      PyObject_SetAttrString(o,"__name__", PyString_FromString("RInvNorm"));
#endif
    }
    



















































/*eof initf2pywraphooks*/
/*eof initf90modhooks*/

  F2PyDict_SetItemString(d, "dist", PyFortranObject_New(f2py_dist_def,f2py_init_dist));
  F2PyDict_SetItemString(d, "param", PyFortranObject_New(f2py_param_def,f2py_init_param));
  F2PyDict_SetItemString(d, "local", PyFortranObject_New(f2py_local_def,f2py_init_local));
  F2PyDict_SetItemString(d, "corr", PyFortranObject_New(f2py_corr_def,f2py_init_corr));
  F2PyDict_SetItemString(d, "index", PyFortranObject_New(f2py_index_def,f2py_init_index));
  F2PyDict_SetItemString(d, "origdim", PyFortranObject_New(f2py_origdim_def,f2py_init_origdim));
  F2PyDict_SetItemString(d, "MCHCOM", PyFortranObject_New(f2py_MCHCOM_def,f2py_init_MCHCOM));
  F2PyDict_SetItemString(d, "data", PyFortranObject_New(f2py_data_def,f2py_init_data));
  F2PyDict_SetItemString(d, "sortdim", PyFortranObject_New(f2py_sortdim_def,f2py_init_sortdim));
  F2PyDict_SetItemString(d, "tmp", PyFortranObject_New(f2py_tmp_def,f2py_init_tmp));
  F2PyDict_SetItemString(d, "flag", PyFortranObject_New(f2py_flag_def,f2py_init_flag));
  F2PyDict_SetItemString(d, "sign", PyFortranObject_New(f2py_sign_def,f2py_init_sign));
  F2PyDict_SetItemString(d, "data1", PyFortranObject_New(f2py_data1_def,f2py_init_data1));
  F2PyDict_SetItemString(d, "shift", PyFortranObject_New(f2py_shift_def,f2py_init_shift));
/*eof initcommonhooks*/


#ifdef F2PY_REPORT_ATEXIT
  if (! PyErr_Occurred())
    on_exit(f2py_report_on_exit,(void*)"test.pyf");
#endif

  return RETVAL;
}
#ifdef __cplusplus
}
#endif
